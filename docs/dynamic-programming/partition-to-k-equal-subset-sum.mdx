import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';



#  Partition to K Equal Subset Sum

This page explains Java solution to leetcode problem [698. Partition to K Equal Sum Subsets](https://leetcode.com/problems/partition-to-k-equal-sum-subsets/description/) using combination approach






## Explanation 

Let's take the sample input as below,

<br />
$$
\text{nums} = \begin{bmatrix}
1,2,3
\end{bmatrix}, \ 
\text{k} = 2
$$
<br />

Initially, we'll verify if the total array sum can be evenly divided into $k$ parts by confirming that 
$$
\text{totalArraySum} \  \% \ k  = \ 0.
$$







## Permutation approach

Let's say we have $N$ elements in an array.

The Idea is for each recursive call, we will iterate over $N$ elements and make another recursive call. Assume \
we picked one element, then we iterate over the array and make recursive calls to remaining $N−1$ \
elements and so on.

Therefore, in the worst-case scenario, the total number of recursive calls will be

$$
N \ ⋅ \ (N−1) \ ⋅ \ (N−2) \ ⋅ \ ... \ ⋅ \ 2 \ ⋅ \ 1 \ = \ N!
$$

<br />








### Implementation
<Tabs>
  <TabItem value="Java" label="Java" default>

```java
class Solution {
     // Function to check if the given array can be partitioned into k subsets 
     // with equal sums
    public boolean canPartitionKSubsets(int[] nums, int k) {
        // Calculate the total sum of the array elements
        int totalArraySum = 0;
        for (int num : nums) {
            totalArraySum += num;
        }
 
       // If the total sum is not divisible by k, return false as equal 
       // partitioning isn't possible 
        if (totalArraySum % k != 0) {
            return false;
        }

        // Check if the array can be partitioned into k subsets with equal sums
        return permute(nums, 0, totalArraySum / k, k, new boolean[nums.length]);
    }

    // Recursive function to find if partitioning is possible
    private boolean permute(int[] nums, int sum, int requiredSum, int k, 
      boolean[] visited) {
        // If all k subsets are formed, return true
        if (k == 0) {
            return true;
        } else if (sum > requiredSum) {
            // If the current sum exceeds the required sum, return false
            return false;
        } else if (sum == requiredSum) {
            // If the current sum matches the required sum, move to the next subset
            return permute(nums, 0, requiredSum, k - 1, visited);
        }

        // Iterate through array elements
        for (int i = 0; i < nums.length; i++) {
            if (visited[i]) continue;
            // Mark element as visited
            visited[i] = true;
            // Recursively check next elements to form the subsets
            if (permute(nums, sum + nums[i], requiredSum, k, visited)) {
                return true;
            }
            // Backtrack if subset with current element doesn't lead to a solution
            visited[i] = false;
        }
        return false;
    }
}
```
</TabItem>
</Tabs>

<br />
:::info[]
Notice how we start the for loop from $0$ every time and continue with the recursive call only if the element hasn't been visited yet.
:::
<br />







Permutation tree will look like below.

<br />
<div style={{textAlign:"center"}}>

```mermaid
graph TD
    A((Root)) --1--> B((&nbsp;&nbsp; 1 &nbsp;&nbsp;))
    A((Root)) --2--> C((&nbsp;&nbsp; 2 &nbsp;&nbsp;))
    A((Root)) --3--> D((&nbsp;&nbsp; 3 &nbsp;&nbsp;))
    
    B --&nbsp;2&nbsp;--> E((&nbsp; 1,2 &nbsp;))
    B --&nbsp;3&nbsp;--> F((&nbsp; 1,3 &nbsp;))
    
    C --&nbsp;1&nbsp;--> G((&nbsp; 2,1 &nbsp;))
    C --&nbsp;3&nbsp;--> H((&nbsp; 2,3 &nbsp;))
    
    D --&nbsp;1&nbsp;--> I((&nbsp; 3,1 &nbsp;))
    D --&nbsp;2&nbsp;--> J((&nbsp; 3,2 &nbsp;))
    
    E --&nbsp;3&nbsp;--> K((&nbsp; 1,2,3 &nbsp;))
    F --&nbsp;2&nbsp;--> L((&nbsp; 1,3,2 &nbsp;))
    G --&nbsp;3&nbsp;--> M((&nbsp; 2,1,3 &nbsp;))
    H --&nbsp;1&nbsp;--> N((&nbsp; 2,3,1 &nbsp;))
    I --&nbsp;2&nbsp;--> O((&nbsp; 3,1,2 &nbsp;))
    J --&nbsp;1&nbsp;--> P((&nbsp; 3,2,1 &nbsp;))
```

</div>
<br />






### Complexity 

Let's say there are $N$ elements in an array.

#### Time complexity 
$
O(N . \ N!)
$

:::warning[]
The complexity of $N!$ makes the permutation approach viable only for smaller inputs.
:::

#### Space complexity
$
O(N)
$
<br />











## Combination Approach
In this problem, the order of items in a subset doesn't make a difference. So, we can use a combination \
method to solve it.


### Implementation
<Tabs>
  <TabItem value="Java" label="Java" default>

```java
class Solution {
     // Function to check if the given array can be partitioned into k subsets 
     // with equal sums
     public boolean canPartitionKSubsets(int[] nums, int k) {
        // Calculate the total sum of the array elements
        int totalArraySum = 0;
        for (int num : nums) {
            totalArraySum += num;
        }

        // If the total sum is not divisible by k, 
        // return false as equal partitioning isn't possible
        if (totalArraySum % k != 0) {
            return false;
        }

        // Check if the array can be partitioned into k subsets with equal sums
        return combination(nums, 0, 0, totalArraySum / k, 
          k, new boolean[nums.length]);
    }

    // Recursive function to find if partitioning is possible
    private boolean combination(int[] nums, int index, int sum, int requiredSum, 
		   int k, boolean[] visited) {
        // If all k subsets are formed, return true
        if (k == 0) {
            return true;
        } else if (sum > requiredSum) {
            // If the current sum exceeds the required sum, return false
            return false;
        } else if (sum == requiredSum) {
            // If the current sum matches the required sum, move to the next subset
            return combination(nums, 0, 0, requiredSum, k - 1, visited);
        }

        // Iterate through array elements
        for (int i = index; i < nums.length; i++) {
            if (visited[i]) {
                continue;
            }
            // Mark element as visited
            visited[i] = true;
            // Recursively check next elements to form the subsets
            if (combination(nums, i + 1, sum + nums[i], requiredSum, k, visited)) {
                return true;
            }
            // Backtrack if subset with current element doesn't lead to a solution
            visited[i] = false;
        }
        return false;
    }
}
```
</TabItem>
</Tabs>

<br />
:::info[]
In Combination approach we begin the for loop from a $\text{index}$ each time and don't reset it to $0$
:::
<br />








Combination tree will look like below.

<br />
<div style={{textAlign:"center"}}>

```mermaid
graph TD
    A((Root)) --1--> B((&nbsp;&nbsp; 1 &nbsp;&nbsp;))
    A((Root)) --2--> C((&nbsp;&nbsp; 2 &nbsp;&nbsp;))
    A((Root)) --3--> D((&nbsp;&nbsp; 3 &nbsp;&nbsp;))
    
    B --&nbsp;2&nbsp;--> E((&nbsp; 1,2 &nbsp;))
		B --&nbsp;3&nbsp;--> F((&nbsp; 1,3 &nbsp;))
    
    C --&nbsp;3&nbsp;--> G((&nbsp; 2,3 &nbsp;))
    
    E --&nbsp;3&nbsp;--> H((&nbsp; 1,2,3 &nbsp;))
```

</div>
<br />










### Complexity 

Let's say there are $N$ elements in an array and we are required to generate $k$ subsets.

#### Time complexity 
$
O(k \ . 2^{N})
$

:::warning[]
The complexity of $O(k \ . 2^{N})$ is slightly better than the complexity of the permutation approach. However, it remains suitable for smaller inputs due to its exponential nature.
:::


#### Space complexity
$
O(N)
$
<br />








## Similar questions

### Capacity To Ship Packages Within D Days

#### Problem Statement
[1011. Capacity To Ship Packages Within D Days](https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/)

<details>
  <summary>Solution</summary>

<Tabs>
  <TabItem value="Java" label="Java" default>

```java
class Solution {
    public int shipWithinDays(int[] weights, int days) {
        int lo = Integer.MIN_VALUE;
        int hi = 0;

        // Determine the bounds for the binary search
        for (int weight : weights) {
            lo = Math.max(lo, weight); d
            hi += weight; 
        }

        // Perform binary search to find the minimum capacity
        while (lo < hi) {
            int mid = lo + (hi - lo) / 2;
            // Check if more days are required
            boolean isMoreDays = daysRequired(weights, mid, days); 
            if (isMoreDays)
                lo = mid + 1; 
            else
                hi = mid; 
        }
        return lo; // Return the minimum capacity
    }

    // Helper function to check if more days are required based on the capacity
    private boolean daysRequired(int[] weights, int capacity, int days) {
        int requiredDays = 1, index = 0, sum = 0;

        // Iterate through the weights to determine the required days
        while (index < weights.length) {
            sum += weights[index]; // Accumulate the sum of weights
            if (sum > capacity) {
                sum = weights[index]; // Reset the sum for a new day
                requiredDays++; // Increment the required days
            }
            index++; // Move to the next weight

            if (requiredDays > days)
                return true; // If required days exceed the given limit
        }
        return false; // If required days are within the given limit
    }
}	
```
</TabItem>
</Tabs>
</details>

