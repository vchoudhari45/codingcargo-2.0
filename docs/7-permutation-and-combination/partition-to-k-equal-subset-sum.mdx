import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';



#  Partition to K Equal Subset Sum

This page explains Java solution to leetcode problem [698. Partition to K Equal Sum Subsets](https://leetcode.com/problems/partition-to-k-equal-sum-subsets/description/) using combination approach






## Explanation 

This problem can be solved using a backtracking approach. This means that for each element in the array, we attempt to assign it to one of the k subsets. However, the time complexity of this approach can be exponential \
($k^N$), where $N$ represents the number of elements.

A more efficient alternative is the permutation approach. Despite having the flexibility to reuse any of the $k$ subsets for array elements, we recognize the stopping point because each subset should have the same total.

Hence, a better approach is to explore all permutations of the array, progressively forming subsets until each one contains an equal sum, resulting in factorial time complexity.


<br />
Let's take the sample input as below,


$$
\text{nums} = \begin{bmatrix}
1,2,3
\end{bmatrix}, \ 
\text{k} = 2
$$
<br />

Initially, we'll verify if the total array sum can be evenly divided into $k$ parts by confirming that 
$$
\text{totalArraySum} \  \% \ k  = \ 0.
$$







## Permutation approach

Let's say we have $N$ elements in an array.

The Idea is for each recursive call, we will iterate over $N$ elements and make another recursive call. Assume we \
picked one element, then we iterate over the array and make recursive calls to remaining $N−1$ elements and \
so on.

Therefore, in the worst-case scenario, the total number of recursive calls will be

$$
N \ ⋅ \ (N−1) \ ⋅ \ (N−2) \ ⋅ \ ... \ ⋅ \ 2 \ ⋅ \ 1 \ = \ N!
$$

<br />




Permutation tree will look like below.

<br />
<div style={{textAlign:"center"}}>

```mermaid
graph TD
    A((Root)) --1--> B((&nbsp;&nbsp; 1 &nbsp;&nbsp;))
    A((Root)) --2--> C((&nbsp;&nbsp; 2 &nbsp;&nbsp;))
    A((Root)) --3--> D((&nbsp;&nbsp; 3 &nbsp;&nbsp;))
    
    B --&nbsp;2&nbsp;--> E((&nbsp; 1,2 &nbsp;))
    B --&nbsp;3&nbsp;--> F((&nbsp; 1,3 &nbsp;))
    
    C --&nbsp;1&nbsp;--> G((&nbsp; 2,1 &nbsp;))
    C --&nbsp;3&nbsp;--> H((&nbsp; 2,3 &nbsp;))
    
    D --&nbsp;1&nbsp;--> I((&nbsp; 3,1 &nbsp;))
    D --&nbsp;2&nbsp;--> J((&nbsp; 3,2 &nbsp;))
    
    E --&nbsp;3&nbsp;--> K((&nbsp; 1,2,3 &nbsp;))
    F --&nbsp;2&nbsp;--> L((&nbsp; 1,3,2 &nbsp;))
    G --&nbsp;3&nbsp;--> M((&nbsp; 2,1,3 &nbsp;))
    H --&nbsp;1&nbsp;--> N((&nbsp; 2,3,1 &nbsp;))
    I --&nbsp;2&nbsp;--> O((&nbsp; 3,1,2 &nbsp;))
    J --&nbsp;1&nbsp;--> P((&nbsp; 3,2,1 &nbsp;))
```

</div>
<br />




### Implementation
<Tabs>
  <TabItem value="Java" label="Java" default>

```java
class Solution {
     // Function to check if the given array can be partitioned into k subsets 
     // with equal sums
    public boolean canPartitionKSubsets(int[] nums, int k) {
        // Calculate the total sum of the array elements
        int totalArraySum = 0;
        for (int num : nums) {
            totalArraySum += num;
        }
 
       // If the total sum is not divisible by k, return false as equal 
       // partitioning isn't possible 
        if (totalArraySum % k != 0) {
            return false;
        }

        // Check if the array can be partitioned into k subsets with equal sums
        return permute(nums, 0, totalArraySum / k, k, new boolean[nums.length]);
    }

    // Recursive function to find if partitioning is possible
    private boolean permute(int[] nums, int sum, int requiredSum, int k, 
      boolean[] visited) {
        // If all k subsets are formed, return true
        if (k == 0) {
            return true;
        } else if (sum > requiredSum) {
            // If the current sum exceeds the required sum, return false
            return false;
        } else if (sum == requiredSum) {
            // If the current sum matches the required sum, move to the next subset
            return permute(nums, 0, requiredSum, k - 1, visited);
        }

        // Iterate through array elements
        for (int i = 0; i < nums.length; i++) {
            if (visited[i]) continue;
            // Mark element as visited
            visited[i] = true;
            // Recursively check next elements to form the subsets
            if (permute(nums, sum + nums[i], requiredSum, k, visited)) {
                return true;
            }
            // Backtrack if subset with current element doesn't lead to a solution
            visited[i] = false;
        }
        return false;
    }
}
```
</TabItem>
</Tabs>

<br />
:::info[]
Notice how we start the for loop from $0$ every time and continue with the recursive call only if the element hasn't been visited yet.
:::
<br />












### Complexity 

Let's say there are $N$ elements in an array.

#### Time complexity 
$
O(N . \ N!)
$

:::warning[]
The complexity of $N!$ makes the permutation approach viable only for smaller inputs.
:::

#### Space complexity
$
O(N)
$
<br />











## Combination Approach
In this problem, the order of items in a subset doesn't make a difference. So, we can use a combination method \
to solve it.





Combination tree will look like below.

<br />
<div style={{textAlign:"center"}}>

```mermaid
graph TD
    A((Root)) --1--> B((&nbsp;&nbsp; 1 &nbsp;&nbsp;))
    A((Root)) --2--> C((&nbsp;&nbsp; 2 &nbsp;&nbsp;))
    A((Root)) --3--> D((&nbsp;&nbsp; 3 &nbsp;&nbsp;))
    
    B --&nbsp;2&nbsp;--> E((&nbsp; 1,2 &nbsp;))
		B --&nbsp;3&nbsp;--> F((&nbsp; 1,3 &nbsp;))
    
    C --&nbsp;3&nbsp;--> G((&nbsp; 2,3 &nbsp;))
    
    E --&nbsp;3&nbsp;--> H((&nbsp; 1,2,3 &nbsp;))
```

</div>
<br />





### Implementation
<Tabs>
  <TabItem value="Java" label="Java" default>

```java
class Solution {
     // Function to check if the given array can be partitioned into k subsets 
     // with equal sums
     public boolean canPartitionKSubsets(int[] nums, int k) {
        // Calculate the total sum of the array elements
        int totalArraySum = 0;
        for (int num : nums) {
            totalArraySum += num;
        }

        // If the total sum is not divisible by k, 
        // return false as equal partitioning isn't possible
        if (totalArraySum % k != 0) {
            return false;
        }

        // Check if the array can be partitioned into k subsets with equal sums
        return combination(nums, 0, 0, totalArraySum / k, 
          k, new boolean[nums.length]);
    }

    // Recursive function to find if partitioning is possible
    private boolean combination(int[] nums, int index, int sum, int requiredSum, 
		   int k, boolean[] visited) {
        // If all k subsets are formed, return true
        if (k == 0) {
            return true;
        } else if (sum > requiredSum) {
            // If the current sum exceeds the required sum, return false
            return false;
        } else if (sum == requiredSum) {
            // If the current sum matches the required sum, move to the next subset
            return combination(nums, 0, 0, requiredSum, k - 1, visited);
        }

        // Iterate through array elements
        for (int i = index; i < nums.length; i++) {
            if (visited[i]) {
                continue;
            }
            // Mark element as visited
            visited[i] = true;
            // Recursively check next elements to form the subsets
            if (combination(nums, i + 1, sum + nums[i], requiredSum, k, visited)) {
                return true;
            }
            // Backtrack if subset with current element doesn't lead to a solution
            visited[i] = false;
        }
        return false;
    }
}
```
</TabItem>
</Tabs>

<br />
:::info[]
In Combination approach we begin the for loop from a $\text{index}$ each time and don't reset it to $0$
:::
<br />















### Complexity 

Let's say there are $N$ elements in an array and we are required to generate $k$ subsets.

#### Time complexity 
$
O(k \ . 2^{N})
$

:::warning[]
The complexity of $O(k \ . 2^{N})$ is slightly better than the complexity of the permutation approach. However, \
it remains suitable for smaller inputs due to its exponential nature.
:::


#### Space complexity
$
O(N)
$
<br />














## Memoization and Bitmasking

We can avoid redundant computations by adding memoization. 

Consider if we've chosen the $0$<sup>th</sup> and $1$<sup>st</sup> elements in set $1$ and the $2$<sup>nd</sup> and $3$<sup>rd</sup> elements in set $2$, but then found 
we can't make set $3$ with the remaining items, we remember this situation.

If in different recursive calls, we selected the $0$<sup>th</sup> and $3$<sup>rd</sup> elements in set $1$, and the $1$<sup>st</sup> and $2$<sup>nd</sup> elements in set $2$, rather than rechecking if we can create set $3$, we retrieve the previously stored answer (false) from memory.


Also, since the number of elements in this problem is limited to $16$, we can efficiently use Bitmasking.


### Implementation

<Tabs>
  <TabItem value="Java" label="Java" default>

```java
class Solution {

    private HashMap<Integer, Boolean> memo;

    // Function to check if the given array can be partitioned 
    // into k subsets with equal sums
    public boolean canPartitionKSubsets(int[] nums, int k) {
        memo = new HashMap<>();

        // Calculate the total sum of the array elements
        int totalArraySum = 0;
        for (int num : nums) {
            totalArraySum += num;
        }

        // If the total sum is not divisible by k, return false as 
        // equal partitioning isn't possible
        if (totalArraySum % k != 0) {
            return false;
        }

        // Check if the array can be partitioned into k subsets with equal sums
        return combination(nums, 0, 0, 0, totalArraySum / k, k);
    }

    // Recursive function to find if partitioning is possible
    private boolean combination(int[] nums, int mask, int index, int sum, 
      int requiredSum, int k) {
        
        if(memo.containsKey(mask)) return memo.get(mask);

        // If all k subsets are formed, return true
        if (k == 0) {
            return true;
        } else if (sum > requiredSum) {
            // If the current sum exceeds the required sum, return false
            return false;
        } else if (sum == requiredSum) {
            // If the current sum matches the required sum, move to the next subset
            boolean ans = combination(nums, mask, 0, 0, requiredSum, k - 1);
            memo.put(mask, ans);
            return ans;
        }

        // Iterate through array elements
        for (int i = index; i < nums.length; i++) {
            // Check if index is already visited 
            if(((mask >> i) & 1) != 0) continue;

            // Mark element as visited
            mask = (mask | (1 << i));

            // Recursively check next elements to form the subsets
            if (combination(nums, mask, i + 1, sum + nums[i], requiredSum, k)) {
                memo.put(mask, true);
                return true;
            }

            // Backtrack if subset with current element doesn't lead to a solution
            mask = (mask ^ (1 << i));
        }
        memo.put(mask, false);
        return false;
    }
}
```
</TabItem>
</Tabs>



### Complexity 

Let's say there are $N$ elements in an array.

#### Time complexity 
$
O(N \ . \ 2^{N})
$


#### Space complexity
$
O(2^{N})
$
<br />





## Choose or Skip approach

The combination approach algorithm can also be expressed as choosing or skipping an element, rather than the previously discussed for loop approach.



### Implementation

<Tabs>
  <TabItem value="Java" label="Java" default>

```java
import java.util.HashMap;

class Solution {

    private HashMap<Integer, Boolean> memo;

    // Checks if the array can be partitioned into k subsets with equal sums
    public boolean canPartitionKSubsets(int[] nums, int k) {
        memo = new HashMap<>();

        int totalArraySum = 0;
        for (int num : nums) {
            totalArraySum += num;
        }

        // If the total sum is not divisible by k, return false
        if (totalArraySum % k != 0) {
            return false;
        }

        return combination(nums, 0, 0, 0, totalArraySum / k, k);
    }

    // Helper function to find subsets with required sum
    private boolean combination(int[] nums, int mask, int index, int sum, 
      int requiredSum, int k) {
        if (memo.containsKey(mask)) return memo.get(mask);

        if (k == 0) {
            return true;
        } else if (sum > requiredSum) {
            return false;
        } else if (sum == requiredSum) {
            // Recursive call to find subsets with reduced k
            boolean ans = combination(nums, mask, 0, 0, requiredSum, k - 1);
            memo.put(mask, ans);
            return ans;
        }

        if (index == nums.length) return false;

        // Choose the current element and explore subsets
        if (((mask >> index) & 1) == 0) {
            mask = (mask | (1 << index));
            if (combination(nums, mask, index + 1, sum + nums[index], 
              requiredSum, k)) {
                memo.put(mask, true);
                return true;
            }
            mask = (mask ^ (1 << index)); // Unchoose the current element
        }
        // Move to the next element without choosing the current one
        if (combination(nums, mask, index + 1, sum, requiredSum, k)) {
            memo.put(mask, true);
            return true;
        }
        memo.put(mask, false);
        return false;
    }
}
```
</TabItem>
</Tabs>



### Complexity 

Let's say there are $N$ elements in an array.

#### Time complexity 
$
O(N \ . \ 2^{N})
$


#### Space complexity
$
O(2^{N})
$
<br />















## Similar questions

### Minimum XOR Sum of Two Arrays

#### Problem Statement
[1879. Minimum XOR Sum of Two Arrays](https://leetcode.com/problems/minimum-xor-sum-of-two-arrays/description/)


<details>
  <summary>Solution</summary>

<Tabs>
  <TabItem value="Java" label="Java" default>

```java
import java.util.HashMap;

class Solution {
    private HashMap<Integer, Integer> memo;

    public int minimumXORSum(int[] nums1, int[] nums2) {
        memo = new HashMap<>();
        return permute(nums1, nums2, 0, 0);
    }

    // Permute method to find the minimum XOR sum
    private int permute(int[] nums1, int[] nums2, int index, int mask) {
        // Check if the mask is memoized
        if (memo.containsKey(mask)) {
            return memo.get(mask);
        }

        // Base case: all elements of nums2 are used
        if (index == nums2.length) {
            return 0;
        } else {
            int ans = Integer.MAX_VALUE;
            for (int i = 0; i < nums2.length; i++) {
                // Skip if the bit at position i in the mask is already set
                if (((mask >> i) & 1) == 1) {
                    continue;
                }

                // Calculate internal answer using XOR and recursion
                int internalAns = (nums1[index] ^ nums2[i]) + permute(
                        nums1,
                        nums2,
                        index + 1,
                        mask | (1 << i)
                );
                ans = Math.min(ans, internalAns);
            }
            memo.put(mask, ans);
            return ans;
        }
    }
}
```
</TabItem>
</Tabs>
</details>










<br />

### Minimum Number of Work Sessions to Finish the Tasks

#### Problem Statement
[1986. Minimum Number of Work Sessions to Finish the Tasks](https://leetcode.com/problems/minimum-number-of-work-sessions-to-finish-the-tasks/description/)


<details>
  <summary>Solution</summary>

<Tabs>
  <TabItem value="Java" label="Java" default>

```java
import java.util.HashMap;

class Solution {
    private HashMap<String, Integer> memo;

    public int minSessions(int[] tasks, int sessionTime) {
        memo = new HashMap<>();
        return permute(tasks, 0, sessionTime, 0);
    }

    // Function to calculate the minimum sessions needed
    private int permute(int[] tasks, int currentSession, int sessionTime, 
      int mask) {
        String key = currentSession + " " + mask;

        // If all tasks are completed, return 1 session
        if (mask == (1 << tasks.length) - 1) {
            return 1;
        } else if (memo.containsKey(key)) { 
            // If memoization contains the calculated result, return the value
            return memo.get(key);
        } else {
            int res = Integer.MAX_VALUE;

            // Iterate through each task to find the minimum sessions required
            for (int i = 0; i < tasks.length; i++) {
                if (((mask >> i) & 1) == 1) {
                    continue; // Skip if task is completed
                }

                // If the current session time plus the task 
                // time exceeds the session time limit
                if (currentSession + tasks[i] > sessionTime) {
                    res = Math.min(
                            res,
                            1 + permute(
                                  tasks,
                                  // Start a new session with the current task
                                  tasks[i], 
                                  sessionTime,
                                  mask | (1 << i)
                            )
                    );
                } else {
                    // Continue the current session with the current task
                    res = Math.min(
                            res,
                            permute(tasks,
                              currentSession + tasks[i],
                              sessionTime,
                              mask | (1 << i)
                            )
                    );
                }
            }

            // Store the calculated result in memoization
            memo.put(key, res);
            return res;
        }
    }
}
```
</TabItem>
</Tabs>
</details>
