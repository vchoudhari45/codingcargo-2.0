import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# 1891. Cutting Ribbons

This page provides explanations and Java solutions for the leetcode problem [Leetcode 1891. Cutting Ribbons](https://leetcode.com/problems/cutting-ribbons/).

## Problem Explanation

The problem is asking us to cut the ribbons into one or more parts, such that each of the $K$ parts will have an equal maximum length. The problem also allows us to discard any extra parts of the ribbons if required.

## Solution

This problem can be solved using the Binary Search technique. More such questions can be found [here](/binary-search/split-array-into-k-subarrays).

Using binary search, we first assume a candidate value($\text{mid}$), and attempt to cut the ribbon at $\text{i}^{th}$ place so that at least one of the part has length equals to candidate value. 

Also, when we find a candidate value that allows the ribbon array to be divided into $K$ parts such that each ribbon part has an equal length, we will set $\text{lo} = \text{mid}$ instead of the typical binary search approach of $\text{lo} = \text{mid} + 1$ to keep the candidate value in the search range.

Now, because we are setting $\text{lo} = \text{mid}$, imagine a scenario where we have $\text{lo} = 2$, $\text{hi} = 3$, and the value $2$ allows the ribbon array to be split into $K$ ribbons, each with a maximum length of $2$. In this case, for next iteration of binary search all the values will remain same and will run infinitely.

To avoid this problem, we set $\text{mid}$ to $(\text{lo} + \text{hi} + 1) / 2$ instead of the typical binary search logic of $\text{mid}$ as $(\text{lo} + \text{hi}) / 2$.


Let's take the sample input below,

$$
\text{sweetness} = \begin{bmatrix} 1, 2, 3, 4, 5, 6, 7, 8, 9 \end{bmatrix},  \ \text{K} = 2
$$

Initiate the binary search using the smallest array value $1$ as the low threshold and the total sum of the array $45$ as the high threshold.

$$
\text{lo} = 1, \ \text{hi} = 45, \ \text{mid} = 23
$$

With a minimum sum as $23$, we can't form three subarrays. The first subarray will have $\begin{bmatrix}1, 2, 3, 4, 5, 6\end{bmatrix}$, second subarray will have $\begin{bmatrix}7, 8, 9\end{bmatrix}$, and third subarray will have $\begin{bmatrix} \ \end{bmatrix}$. Because third subarray have sum less than $23$, let's decrease the higher threshold.

$$
\text{lo} = 1, \ \text{hi} = 22, \ \text{mid} = 12
$$

With a minimum sum of $12$, we can make three subarrays the first will have $\begin{bmatrix}1, 2, 3, 4, 5\end{bmatrix}$, second will have $\begin{bmatrix}6, 7\end{bmatrix}$ and third subarray will have $\begin{bmatrix}8, 9\end{bmatrix}$. Because all of the subarray sums are greater than $12$, let's maximize the candidate value further, by increasing the lower threshold.

$$
\text{lo} = 12, \ \text{hi} = 22, \ \text{mid} = 17
$$

:::info[]
Observe that we're setting $\text{lo} = \text{mid}$ instead of $\text{lo} = \text{mid} + 1$ because we want to maintain the candidate value of $12$ within the search space.

This is because, in the next iteration of binary search, we might find a candidate value (let's call it $X$) that is greater than $12$, and if $X$ does not allow splitting the array into $K$ subarrays with all subarray sums greater than or equal to $X$, then $12$ should be our answer.
:::


With a minimum sum of $17$, we can't form three subarrays. The first subarray will have $\begin{bmatrix}1, 2, 3, 4, 5, 6\end{bmatrix}$, second subarray will have $\begin{bmatrix}7, 8, 9\end{bmatrix}$, and third subarray will have $\begin{bmatrix} \ \end{bmatrix}$. Because third subarray have sum less than $17$, let's decrease the higher threshold.

$$
\text{lo} = 12, \ \text{hi} = 16, \ \text{mid} = 14
$$

With a minimum sum of $14$, we can't form three subarrays. The first subarray will have $\begin{bmatrix}1, 2, 3, 4, 5, 6\end{bmatrix}$, second subarray will have $\begin{bmatrix}7, 8\end{bmatrix}$, and third subarray will have $\begin{bmatrix} 9 \end{bmatrix}$. Because third subarray have sum less than $14$, let's decrease the higher threshold.


$$
\text{lo} = 12, \ \text{hi} = 13, \ \text{mid} = 13
$$

With a minimum sum of $13$, we can make three subarrays the first will have $\begin{bmatrix}1, 2, 3, 4, 5\end{bmatrix}$, second will have $\begin{bmatrix}6, 7\end{bmatrix}$ and third subarray will have $\begin{bmatrix}8, 9\end{bmatrix}$. Because all of the subarray sums are greater than $13$, let's maximize the candidate value further, by increasing the lower threshold.


$$
\text{lo} = 13, \ \text{hi} = 13, \ \text{mid} = 13
$$

Because the lower limit equals the upper limit, we exit the binary search, finding the answer as $13$.


## Implementation

<Tabs>
  <TabItem value="Java" label="Java" default>

```java
class Solution {
    public int maximizeSweetness(int[] sweetness, int k) {
        // Initialize the lower bound `lo` and the upper bound `hi`
        int lo = Integer.MAX_VALUE;
        int hi = 0;

        // Loop through the sweetness array to calculate the minimum and maximum sweetness
        for (int i = 0; i < sweetness.length; i++) {
            lo = Math.min(lo, sweetness[i]);
            hi += sweetness[i];
        }

        // Increment `k` by 1, including you total people will become k + 1
        k++;

        // Binary search to find the maximum sweetness value
        while (lo < hi) {
            int mid = (lo + hi + 1) / 2; // Calculate the middle value

            // Get the number of partitions
            int partitions = getPartitions(sweetness, mid); 

            // Adjust bounds based on the number of partitions
            if (partitions < k) hi = mid - 1;
            else lo = mid;
        }

        return lo; // Return the maximum sweetness value found
    }

    /**
     * Method to calculate the number of partitions achievable 
     * based on a sweetness threshold
     */
    private int getPartitions(int[] nums, int required) {
        int index = 0, sum = 0, partitions = 0;

        // Iterate through the sweetness array and count the partitions
        while (index < nums.length) {
            sum += nums[index];

            // Check if the current sum meets the required sweetness threshold
            if (sum >= required) {
                sum = 0; // Reset sum for the next partition
                partitions++; // Increment partitions count
            }

            index++; // Move to the next sweetness value
        }

        return partitions; // Return the total partitions achieved
    }
}
```
</TabItem>
</Tabs>

## Complexity 

Let's say there are $N$ elements in an array, and total sum of all elements in an array is $S$.

### Time complexity 

The time complexity is $O(\log S)$ for searching the optimal solution using binary search, and $O(N)$ for checking if the array can be split into $K$ subarrays. 

Total time complexity will be, 

$$
O(N \ \text{log} \ S)
$$



### Space complexity

The solution uses constant space for storing binary search variables.

$$
O(1)
$$

