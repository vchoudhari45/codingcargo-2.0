import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# 1231. Divide Chocolate

This page provides solutions for the leetcode problem [LeetCode 2591. Distribute Money to Maximum Children](https://leetcode.com/problems/distribute-money-to-maximum-children/).

## Problem Explanation

The problem is asking us to divide a chocolate into $\text{K} + 1$ pieces such that you maximize the minimum total sweetness. Total sweetness here refers to the sum of elements of a subarray.

## Solution

This problem can be solved using the Binary Search technique to split an array into $\text{K}$ subarrays. [More such questions can be found here](/binary-search/split-array-into-k-subarrays).

Using binary search, we first assume a candidate value($\text{mid}$), and attempt to split the array(Chocolate in this case) into $\text{K}$ subarrays with sums greater than or equal to candidate value.

Also, when we find a candidate value that allows the array to be split into $\text{K}$ subarrays such that each subarray sum is greater than or equal to the candidate value, we will set $\text{lo} = \text{mid}$ instead of the typical binary search approach of $\text{lo} = \text{mid} + 1$ to keep the candidate value in the search range.

Now, because we are setting $\text{lo} = \text{mid}$, imagine a scenario where we have $\text{lo} = 2$, $\text{hi} = 3$, and the value $2$ allows the array to be split into $\text{K}$ subarrays such that the sum of all the subarrays is greater than or equal to $2$. In this case for next iteration of binary search all the values will remain same and will run infinitely. 

To avoid this problem, we set $\text{mid}$ to $(\text{lo} + \text{hi} + 1) / 2$ instead of the typical binary search logic of $\text{mid}$ as $(\text{lo} + \text{hi}) / 2$.

There is one more thing to notice here, the question asks us to share the chocolate among $\text{K}$ friends and also take the one piece for yourself, meaning the question is asking us to divide the chocolate among $\text{K} + 1$ people.


Let's take the sample input below,

$$
\text{sweetness} = \begin{bmatrix} 1, 2, 3, 4, 5, 6, 7, 8, 9 \end{bmatrix},  \ \text{K} = 2
$$

Initiate the binary search using the smallest array value $1$ as the low threshold and the total sum of the array $45$ as the high threshold.

$$
\text{lo} = 1, \ \text{hi} = 45, \ \text{mid} = 23
$$

With a minimum sum as $23$, we can't form three subarrays. The first subarray will have $\begin{bmatrix}1, 2, 3, 4, 5, 6\end{bmatrix}$, second subarray will have $\begin{bmatrix}7, 8, 9\end{bmatrix}$, and third subarray will have $\begin{bmatrix} \ \end{bmatrix}$. Because third subarray have sum less than $23$, let's decrease the higher threshold.

$$
\text{lo} = 1, \ \text{hi} = 22, \ \text{mid} = 12
$$

With a minimum sum of $12$, we can make three subarrays the first will have $\begin{bmatrix}1, 2, 3, 4, 5\end{bmatrix}$, second will have $\begin{bmatrix}6, 7\end{bmatrix}$ and third subarray will have $\begin{bmatrix}8, 9\end{bmatrix}$. Because all of the subarray sums are greater than $12$, let's maximize the candidate value further, by increasing the lower threshold.

$$
\text{lo} = 12, \ \text{hi} = 22, \ \text{mid} = 17
$$

:::info[]
Observe that we're setting $\text{lo} = \text{mid}$ instead of $\text{lo} = \text{mid} + 1$ because we want to maintain the candidate value of $12$ within the search space.

This is because, in the next iteration of binary search, we get a candidate value as $17$. If candiate value of $17$ does not allow splitting the array into $\text{K}$ subarrays with all subarray sums greater than or equal to $17$, then $12$ should be our answer.
:::


With a minimum sum of $17$, we can't form three subarrays. The first subarray will have $\begin{bmatrix}1, 2, 3, 4, 5, 6\end{bmatrix}$, second subarray will have $\begin{bmatrix}7, 8, 9\end{bmatrix}$, and third subarray will have $\begin{bmatrix} \ \end{bmatrix}$. Because third subarray have sum less than $17$, let's decrease the higher threshold.

$$
\text{lo} = 12, \ \text{hi} = 16, \ \text{mid} = 14
$$

With a minimum sum of $14$, we can't form three subarrays. The first subarray will have $\begin{bmatrix}1, 2, 3, 4, 5, 6\end{bmatrix}$, second subarray will have $\begin{bmatrix}7, 8\end{bmatrix}$, and third subarray will have $\begin{bmatrix} 9 \end{bmatrix}$. Because third subarray have sum less than $14$, let's decrease the higher threshold.


$$
\text{lo} = 12, \ \text{hi} = 13, \ \text{mid} = 13
$$

With a minimum sum of $13$, we can make three subarrays the first will have $\begin{bmatrix}1, 2, 3, 4, 5\end{bmatrix}$, second will have $\begin{bmatrix}6, 7\end{bmatrix}$ and third subarray will have $\begin{bmatrix}8, 9\end{bmatrix}$. Because all of the subarray sums are greater than $13$, let's maximize the candidate value further, by increasing the lower threshold.


$$
\text{lo} = 13, \ \text{hi} = 13, \ \text{mid} = 13
$$

Because the lower limit equals the upper limit, we exit the binary search, finding the answer as $13$.


## Implementation

<Tabs>
  <TabItem value="Java" label="Java" default>

```java
class Solution {
    public int distMoney(int money, int children) {
        int lo = -1;
        int hi = children;
        while(lo < hi) {
            int mid = (lo + hi + 1) / 2;
            if(isValid(money, mid, children)) lo = mid;
            else hi = mid - 1;
        }
        return lo;
    }

    private boolean isValid(int money, int maxChlidren, int children) {
        int remainingMoney = money - 8 * maxChlidren;
        int remainingChildren = children - maxChlidren;
        if(remainingMoney == 4 && remainingChildren == 1) return false;
        else if(remainingMoney < remainingChildren) return false;
        else if(remainingMoney > 0 && remainingChildren == 0) return false;
        else return true;
    }
}
```
</TabItem>
</Tabs>

## Complexity 

Let's say there are $\text{N}$ elements in an array, and total sum of all elements in an array is $\text{S}$.

### Time complexity 

The time complexity is $\text{O}(\log \text{S})$ for searching the optimal solution using binary search, and $\text{O}(\text{N})$ for checking if the array can be split into $\text{K}$ subarrays. 

Total time complexity will be, 

$$
\text{O}(\text{N} \log \text{S})
$$



### Space complexity

The solution uses constant space for storing binary search variables.

$$
\text{O}(1)
$$

