import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# 1231. Divide Chocolate

This page provides solutions for the leetcode problem [1231. Divide Chocolate](https://leetcode.com/problems/divide-chocolate/).

## Problem Explanation

The problem is asking us to divide a chocolate into $K + 1$ pieces such that you maximize the minimum total sweetness. Total sweetness here refers to the sum of elements of a subarray.

## Solution

This problem can be solved using the Binary Search technique to split an array into $K$ subarrays. [More such questions can be found here](/binary-search/split-array-into-k-subarrays).

Using binary search, we first assume a candidate value($\text{mid}$), and attempt to split the array(Chocolate in this case) into $K$ subarrays with sums greater than or equal to this candidate value.

Also, when we find a candidate value that allows the array to be split into $K$ subarrays such that each subarray sum is greater than or equal to the candidate value, we will set $\text{lo} = \text{mid}$ instead of the typical binary search approach of $\text{lo} = \text{mid} + 1$ to keep the candidate value in the search range.

Now, because we are setting $\text{lo} = \text{mid}$, imagine a scenario where we have $\text{lo} = 2$, $\text{hi} = 3$, and the value $2$ allows the array to be split into $K$ subarrays such that the sum of all the subarrays is greater than or equal to $2$. In this case for next iteration of binary search all the values will remain same and will run infinitely. 

To avoid this problem, we set $\text{mid}$ to $(\text{lo} + \text{hi} + 1) / 2$ instead of the typical binary search logic of $\text{mid}$ as $(\text{lo} + \text{hi}) / 2$.

There is one more thing to notice here, the question asks us to share the chocolate among $K$ friends and also take the one piece for yourself, meaning the question is asking us to divide the chocolate among $K + 1$ people.


Let's take the sample input below,

$$
\text{sweetness} = \begin{bmatrix} 1, 2, 3, 4, 5, 6, 7, 8, 9 \end{bmatrix},  \ \text{K} = 2
$$

Initiate the binary search using the smallest array value $1$ as the low threshold and the total sum of the array $45$ as the high threshold.

$$
\text{lo} = 1, \ \text{hi} = 45, \ \text{mid} = 23
$$

With a minimum sum as $23$, we can't form three subarrays. The first subarray will have $\begin{bmatrix}1, 2, 3, 4, 5, 6\end{bmatrix}$, second subarray will have $\begin{bmatrix}7, 8, 9\end{bmatrix}$, and third subarray will have $\begin{bmatrix} \ \end{bmatrix}$. Because third subarray have sum less than $23$, let's decrease the higher threshold.

$$
\text{lo} = 1, \ \text{hi} = 22, \ \text{mid} = 12
$$

With a minimum sum of $12$, we can make three subarrays the first will have $\begin{bmatrix}1, 2, 3, 4, 5\end{bmatrix}$, second will have $\begin{bmatrix}6, 7\end{bmatrix}$ and third subarray will have $\begin{bmatrix}8, 9\end{bmatrix}$. Because all of the subarray sums are greater than $12$, let's maximize the candidate value further, by increasing the lower threshold.

$$
\text{lo} = 12, \ \text{hi} = 22, \ \text{mid} = 17
$$

:::info[]
Observe that we're setting $\text{lo} = \text{mid}$ instead of $\text{lo} = \text{mid} + 1$ because we want to maintain the candidate value of $12$ within the search space.

This is because, in the next iteration of binary search, we have a candidate value as $17$. If candiate value of $17$ does not allow splitting the array into $K$ subarrays with all subarray sums greater than or equal to $17$, then $12$ should be our answer.
:::


With a minimum sum of $17$, we can't form three subarrays. The first subarray will have $\begin{bmatrix}1, 2, 3, 4, 5, 6\end{bmatrix}$, second subarray will have $\begin{bmatrix}7, 8, 9\end{bmatrix}$, and third subarray will have $\begin{bmatrix} \ \end{bmatrix}$. Because third subarray have sum less than $17$, let's decrease the higher threshold.

$$
\text{lo} = 12, \ \text{hi} = 16, \ \text{mid} = 14
$$

With a minimum sum of $14$, we can't form three subarrays. The first subarray will have $\begin{bmatrix}1, 2, 3, 4, 5, 6\end{bmatrix}$, second subarray will have $\begin{bmatrix}7, 8\end{bmatrix}$, and third subarray will have $\begin{bmatrix} 9 \end{bmatrix}$. Because third subarray have sum less than $14$, let's decrease the higher threshold.


$$
\text{lo} = 12, \ \text{hi} = 13, \ \text{mid} = 13
$$

With a minimum sum of $13$, we can make three subarrays the first will have $\begin{bmatrix}1, 2, 3, 4, 5\end{bmatrix}$, second will have $\begin{bmatrix}6, 7\end{bmatrix}$ and third subarray will have $\begin{bmatrix}8, 9\end{bmatrix}$. Because all of the subarray sums are greater than $13$, let's maximize the candidate value further, by increasing the lower threshold.


$$
\text{lo} = 13, \ \text{hi} = 13, \ \text{mid} = 13
$$

Because the lower limit equals the upper limit, we exit the binary search, finding the answer as $13$.


## Implementation

<Tabs>
  <TabItem value="Java" label="Java" default>

```java
class Solution {
    public int maximizeSweetness(int[] sweetness, int k) {
        int lo = Integer.MAX_VALUE;
        int hi = 0;

        for (int i = 0; i < sweetness.length; i++) {
            lo = Math.min(lo, sweetness[i]);
            hi += sweetness[i];
        }

        k++;

        while (lo < hi) {
            int mid = (lo + hi + 1) / 2; 

            int partitions = getPartitions(sweetness, mid); 

            if (partitions < k) hi = mid - 1;
            else lo = mid;
        }

        return lo;
    }

    private int getPartitions(int[] nums, int required) {
        int index = 0, sum = 0, partitions = 0;

        while (index < nums.length) {
            sum += nums[index];

            if (sum >= required) {
                sum = 0;
                partitions++;
            }

            index++;
        }

        return partitions;
    }
}
```
</TabItem>
</Tabs>

## Complexity 

Let's say there are $N$ elements in an array, and total sum of all elements in an array is $S$.

### Time complexity 

The time complexity is $O(\log S)$ for searching the optimal solution using binary search, and $O(N)$ for checking if the array can be split into $K$ subarrays. 

Total time complexity will be, 

$$
O(N \ \text{log} \ S)
$$



### Space complexity

The solution uses constant space for storing binary search variables.

$$
O(1)
$$

