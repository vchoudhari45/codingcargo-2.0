import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# 410. Split Array Largest Sum

This page provides solutions for the leetcode problem [410. Split Array Largest Sum](https://leetcode.com/problems/split-array-largest-sum/).

## Problem Explaination 

The problem is asking us to split an array into $K$ subarrays in such a way that the largest sum of any subarray is minimized.

## Solution

This problem can be solved using the Binary Search technique to split an array into $K$ subarrays. [More such questions can be found here](/binary-search/split-array-into-k-subarrays).

Using binary search, we first assume a candidate value($\text{mid}$), and attempt to split the array into $K$ subarrays with sums less than or equal to this candidate value.

Also, when we find a candidate value that allows the array to be split into $K$ subarrays such that each subarray sum is less than or equal to the candidate value, we will set $\text{hi} = \text{mid}$ instead of the typical binary search approach of $\text{hi} = \text{mid} - 1$ to keep the candidate value in the search range.

Let's take the sample input below,

$$
\text{nums} = \begin{bmatrix} 7, 2, 5, 10, 8\end{bmatrix},  \ \text{K} = 2
$$

Initiate the binary search using the largest array value $10$ as the low threshold and the total sum of the array $32$ as the high threshold.

$$
\text{lo} = 10, \ \text{hi} = 32, \ \text{mid} = 21
$$

With a maximum sum as $21$, the first subarray will have $\begin{bmatrix}7, 2, 5\end{bmatrix}$, and the second subarray will have $\begin{bmatrix}10, 8\end{bmatrix}$. Because none of the subarray sums exceed the value of $21$, let's minimize the candidate value further, by decreasing the higher threshold.

$$
\text{lo} = 10, \ \text{hi} = 21, \ \text{mid} = 15
$$

:::info[]
Observe that we're setting $\text{hi} = \text{mid}$ instead of $\text{hi} = \text{mid} - 1$ because we want to maintain the candidate value of $21$ within the search space.

This is because, in the next iteration of binary search, we have a candidate value of $15$. If $15$ does not allow splitting the array into $K$ subarrays with all subarray sums less than or equal to $15$, then $21$ should be our answer.
:::

With a maximum sum as $15$, we can't form two subarrays. The first subarray $\begin{bmatrix}7, 2, 5\end{bmatrix}$ is fine, but the second subarray $\begin{bmatrix}10, 8\end{bmatrix}$ exceeds the max sum of $15$. Because array can't be split into $K=2$ subarrays with each subarray having a sum less than or equal to $15$, let's increase the lower threshold.

$$
\text{lo} = 16, \ \text{hi} = 21, \ \text{mid} = 18
$$

With a maximum sum of $18$, we can make two subarrays the first will have $\begin{bmatrix}7, 2, 5\end{bmatrix}$ and the second will have $\begin{bmatrix}10, 8\end{bmatrix}$. Because none of the subarray sums exceed the value of $18$, let's minimize the candidate value further, by decreasing the higher threshold.

$$
\text{lo} = 16, \ \text{hi} = 18, \ \text{mid} = 17
$$

With a maximum sum of $17$, we can't form two subarrays. The first subarray $\begin{bmatrix}7, 2, 5\end{bmatrix}$ is fine, but the second subarray $\begin{bmatrix}10, 8\end{bmatrix}$ exceeds the max sum of $17$. Because array can't be split into $K=2$ subarrays with each subarray having a sum less than or equal to $17$, let's increase the lower threshold.


$$
\text{lo} = 18, \ \text{hi} = 18, \ \text{mid} = 18
$$

Because the lower limit equals the upper limit, we exit the binary search, finding the answer as $18$.


## Implementation

<Tabs>
  <TabItem value="Java" label="Java" default>

```java
class Solution {
    public int splitArray(int[] nums, int k) {
        int lo = Integer.MIN_VALUE;
        int hi = 0;
        
        for (int num : nums) {
            lo = Math.max(lo, num); 
            hi += num; 
        }

        while (lo < hi) {
            int mid = lo + (hi - lo) / 2; 
            
            int partitions = getPartitions(nums, mid); 

            if (partitions > k) lo = mid + 1; 
            else hi = mid; 
        }
        return lo; 
    }

    private int getPartitions(int[] nums, int required) {
        int index = 0, sum = 0, partition = 1;

        while (index < nums.length) {
            sum += nums[index]; 
            if (sum > required) {
                sum = nums[index]; 
                partition++; 
            }
            index++;
        }
        return partition;
    }
}
```
</TabItem>
</Tabs>

## Complexity 

Let's say there are $N$ elements in an array, and total sum of all elements in an array is $S$.

### Time complexity 

The time complexity is $O(\log S)$ for searching the optimal solution using binary search, and $O(N)$ for checking if the array can be split into $K$ subarrays. 

Total time complexity will be, 

$$
O(N \ \text{log} \ S)
$$



### Space complexity

The solution uses constant space for storing binary search variables.

$$
O(1)
$$

