import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# 2064. Minimized Maximum of Pr...

This page provides solutions for the leetcode problem [2064. Minimized Maximum of Products Distributed to Any Store](https://leetcode.com/problems/minimized-maximum-of-products-distributed-to-any-store).


## Problem Explaination 

The problem is asking us to distribute product, given in a product array $\text{quantities}$, into $\text{n}$ stores such that each store is given at most a single product type but in any quantity. This distribution should try to minimize the maximum number of products a single store has.
 

## Solution

This problem can be solved using the Binary Search technique. [More such questions can be found here](/binary-search/split-array-into-k-subarrays).

Using binary search, we first assume a candidate value($\text{mid}$), and attempt to distribute products quantities into $\text{n}$ subarrays(stores in this case).

Also, when we find a candidate value that allows the array to be split into $\text{n}$ subarrays such that each subarray sum is less than or equal to the candidate value, we will set $\text{hi} = \text{mid}$ instead of the typical binary search approach of $\text{hi} = \text{mid} - 1$ to keep the candidate value in the search range.

Let's take the sample input below,

$$
\text{nums} = \begin{bmatrix} 15, 10, 10\end{bmatrix},  \ \text{n} = 7
$$

:::info[Assumption]
Assume $\text{n} = 7$ stores are named as $\text{A}, \text{B}, \text{C}, \text{D}, \text{E}, \text{F}$, and $\text{G}$. 

Also let's assume product type at $0^{\text{th}}$ index is called $\text{P}1$, product type at $1^{\text{st}}$ index is called $\text{P}2$ and product type at $2^{\text{nd}}$ index is called $\text{P}3$. 
:::

Initiate the binary search using value $1$ as the low threshold and largest element of an array $15$ as the high threshold.

$$
\text{lo} = 1, \ \text{hi} = 15, \ \text{mid} = 8
$$

With a maximum value as $8$, we can assign items as below: 

- Product type $\text{P}1$ is distributed to $2$ stores: $\text{A}$ gets $8$, and $\text{B}$ gets $7$ of the total $15$ items.
- Product type $\text{P}2$ is distributed to $2$ stores: $\text{C}$ gets $8$, and $\text{D}$ gets $3$ of the total $10$ items.
- Product type $\text{P}3$ is distributed to $2$ stores: $\text{E}$ gets $8$, and $\text{F}$ gets $3$ of the total $10$ items.
- $\text{G}$ store gets no items.

Since none of the stores has more than $1$ product type, maximum value of $8$ works. Let's try to minimize the candidate value by lowering the higher threshold.


$$
\text{lo} = 1, \ \text{hi} = 8, \ \text{mid} = 4
$$

:::info[]
Observe that we're setting $\text{hi} = \text{mid}$ instead of $\text{hi} = \text{mid} - 1$ because we want to maintain the candidate value of $8$ within the search space.

This is because, in the next iteration of binary search, we get a candidate value as $4$. If $4$ does not allow distributing products into $\text{n}$ stores with each store getting at most $1$ product type, then $8$ should be our answer.
:::

With a maximum value as $4$, we can assign items as below: 

- Product type $\text{P}1$ is distributed to $4$ stores: $\text{A}$ gets $4$, $\text{B}$ gets $4$, $\text{C}$ gets $4$, and $\text{D}$ gets $3$ of the total $15$ items.
- Product type $\text{P}2$ is distributed to $3$ stores: $\text{E}$ gets $4$, $\text{F}$ gets $4$, and $\text{G}$ gets $2$ of the total $10$ items.
- Product type $\text{P}3$ can't be assigned to any of the store, as each store already has at most $1$ product type.

Since we can't assign all products items to $\text{n}$ stores with maximum candidate value of $4$, let's increase lower threashold.

$$
\text{lo} = 5, \ \text{hi} = 8, \ \text{mid} = 6
$$

With a maximum value as $6$, we can assign items as below: 

- Product type $\text{P}1$ is distributed to $3$ stores: $\text{A}$ gets $6$, $\text{B}$ gets $6$, and $\text{C}$ gets $3$ of the total $15$ items.
- Product type $\text{P}2$ is distributed to $2$ stores: $\text{D}$ gets $6$, and $\text{E}$ gets $4$ of the total $10$ items.
- Product type $\text{P}3$ is distributed to $2$ stores: $\text{F}$ gets $6$, and $\text{G}$ gets $4$ of the total $10$ items.

Since none of the stores has more than $1$ product type, maximum value of $6$ works. Let's try to minimize the candidate value by lowering the higher threshold.


$$
\text{lo} = 5, \ \text{hi} = 6, \ \text{mid} = 5
$$

With a maximum value as $5$, we can assign items as below: 

- Product type $\text{P}1$ is distributed to $3$ stores: $\text{A}$ gets $5$, $\text{B}$ gets $5$, and $\text{C}$ gets $5$ of the total $15$ items.
- Product type $\text{P}2$ is distributed to $2$ stores: $\text{D}$ gets $5$, and $\text{E}$ gets $5$ of the total $10$ items.
- Product type $\text{P}3$ is distributed to $2$ stores: $\text{F}$ gets $5$, and $\text{G}$ gets $5$ of the total $10$ items.

Since none of the stores has more than $1$ product type, maximum value of $5$ works. Let's try to minimize the candidate value by lowering the higher threshold.

$$
\text{lo} = 5, \ \text{hi} = 5, \ \text{mid} = 5
$$

Because the lower limit equals the upper limit, we exit the binary search, finding the answer as $5$.


## Implementation

<Tabs>
  <TabItem value="Java" label="Java" default>

```java
class Solution {
    public int minimizedMaximum(int n, int[] quantities) {
        int lo = 1;
        int hi = Integer.MIN_VALUE;
        for(int i = 0; i < quantities.length; i++) {
            hi = Math.max(hi, quantities[i]);
        }

        while(lo < hi) {
            int mid = (lo + hi) / 2;
            int partitions = getPartitions(quantities, mid);
            if(partitions > n) lo = mid + 1;
            else hi = mid;
        }
        return lo;
    }

    private int getPartitions(int[] quantities, int required) {
        int partitions = 0;
        for(int i = 0; i < quantities.length; i++) {
            partitions += quantities[i] / required;
            if(quantities[i] % required != 0) 
                partitions++;           
        }
        return partitions;
    }
}
```
</TabItem>
</Tabs>

## Complexity 

Let's say there are $\text{N}$ elements in an array, and total sum of all elements in an array is $\text{S}$.

### Time complexity 

The time complexity is $\text{O}(\log \text{S})$ for searching the optimal solution using binary search, and $\text{O}(\text{N})$ for checking if the array can be split into $\text{K}$ subarrays. 

Total time complexity will be, 

$$
\text{O}(\text{N} \log \text{S})
$$



### Space complexity

The solution uses constant space for storing binary search variables.

$$
\text{O}(1)
$$

