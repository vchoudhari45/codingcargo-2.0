import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';



#  Template

This page explains Java solution to leetcode problem [410. Split Array Largest Sum](https://leetcode.com/problems/split-array-largest-sum/description/) using Binary Search \
algorithm.





## Explanation 
Often, split array into sub-arrays questions can be solved by repeatedly applying binary search to meet \
the specified conditions.


Let's take the sample input as below,

<br />
$$
\text{nums} = \begin{bmatrix}
7, & 2, & 5 & 10 & 8
\end{bmatrix}, 
\  \text{k} = 2
$$
<br />

Initiate the binary search using the largest array value $10$ as the low threshold and the total sum of the \
array $32$ as the high threshold.

<br />
$$
\text{lo} = 10, \ \text{hi} = 32, \ \text{mid} = 21
$$
<br />

With maximum sum as $21$, the first subarray will have $\begin{bmatrix}7, & 2, & 5\end{bmatrix}$, and the second subarray will have \
$\begin{bmatrix}10, & 8\end{bmatrix}$. Since none of the subarray sums exceed value of $21$, let's lower the upper threshold to minimize \
search value further.

<br />
$$
\text{lo} = 10, \ \text{hi} = 21, \ \text{mid} = 15
$$


:::info[]
Observe that we're setting $\text{hi} = \text{mid}$ instead of $\text{mid} - 1$. This maintains the value of $21$(which satisfies given condition) within the search range.
:::

<br />
With a maximum sum as $15$, we can't form two subarrays. The first subarray $\begin{bmatrix}7, & 2, & 5\end{bmatrix}$ is fine, but the \
second subarray $\begin{bmatrix}10, & 8\end{bmatrix}$ exceeds the max sum of $15$. Let's increase the lower threshold.

<br />
$$
\text{lo} = 16, \ \text{hi} = 21, \ \text{mid} = 18
$$
<br />

With a maximum sum of $18$, we made two subarrays the first with numbers $\begin{bmatrix}7, & 2, & 5\end{bmatrix}$ and the second \
with numbers $\begin{bmatrix}10, & 8\end{bmatrix}$. Since none of the subarray sums exceed value of $18$ let's lower the upper threshold \
to minimize search value further.

<br />
$$
\text{lo} = 16, \ \text{hi} = 18, \ \text{mid} = 17
$$
<br />

With a maximum sum of $17$, we can't form two subarrays. The first subarray $\begin{bmatrix}7, & 2, & 5\end{bmatrix}$ is fine, but the \
second subarray $\begin{bmatrix}10, & 8\end{bmatrix}$ exceeds the max sum of $17$. Let's increase the lower threshold.

<br />
$$
\text{lo} = 18, \ \text{hi} = 18, \ \text{mid} = 18
$$
<br />


Since the lower limit equals the upper limit, we exit the binary search, finding the answer as $18$.







## Implementation
<Tabs>
  <TabItem value="Java" label="Java" default>

```java
class Solution {
    public int splitArray(int[] nums, int k) {
        // Initialize the lower and upper bounds for binary search
        int lo = Integer.MIN_VALUE;
        int hi = 0;
        
        // Determine the bounds for the binary search
        for (int num : nums) {
            lo = Math.max(lo, num); 
            hi += num; 
        }

        // Perform binary search
        while (lo < hi) {
            int mid = lo + (hi - lo) / 2; 
            // Check if more partitions are needed
            boolean isMore = isMorePartition(nums, mid, k); 
            if (isMore)
                lo = mid + 1; 
            else
                hi = mid; 
        }
        return lo; 
    }

    // Helper function to check if more partitions are required
    private boolean isMorePartition(int[] nums, int required, int k) {
        int index = 0, sum = 0, partition = 1;

        // Iterate through the array to check for partitions
        while (index < nums.length) {
            sum += nums[index]; // Accumulate the sum
            if (sum > required) {
                sum = nums[index]; // Reset the sum for a new partition
                partition++; // Increment the partition count
            }
            index++; // Move to the next element

            if (partition > k)
                return true; // If partitions exceed the given count, return true
        }
        return false; // Return false if partitions are within the given count
    }
}
```
</TabItem>
</Tabs>








## Complexity 

Let's say there are $N$ elements in an array, and total sum of all elements in an array is $S$.

### Time complexity 
$
O(N \ \text{log} \ S)
$

### Space complexity
$
O(1)
$








## Similar questions

### &#8226;&nbsp;Capacity To Ship Packages Within D Days

#### Problem Statement
[1011. Capacity To Ship Packages Within D Days](https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/)

<details>
  <summary>Solution</summary>

<Tabs>
  <TabItem value="Java" label="Java" default>

```java
class Solution {
    public int shipWithinDays(int[] weights, int days) {
        int lo = Integer.MIN_VALUE;
        int hi = 0;

        // Determine the bounds for the binary search
        for (int weight : weights) {
            lo = Math.max(lo, weight); d
            hi += weight; 
        }

        // Perform binary search to find the minimum capacity
        while (lo < hi) {
            int mid = lo + (hi - lo) / 2;
            // Check if more days are required
            boolean isMoreDays = daysRequired(weights, mid, days); 
            if (isMoreDays)
                lo = mid + 1; 
            else
                hi = mid; 
        }
        return lo; // Return the minimum capacity
    }

    // Helper function to check if more days are required based on the capacity
    private boolean daysRequired(int[] weights, int capacity, int days) {
        int requiredDays = 1, index = 0, sum = 0;

        // Iterate through the weights to determine the required days
        while (index < weights.length) {
            sum += weights[index]; // Accumulate the sum of weights
            if (sum > capacity) {
                sum = weights[index]; // Reset the sum for a new day
                requiredDays++; // Increment the required days
            }
            index++; // Move to the next weight

            if (requiredDays > days)
                return true; // If required days exceed the given limit
        }
        return false; // If required days are within the given limit
    }
}	
```
</TabItem>
</Tabs>
</details>
