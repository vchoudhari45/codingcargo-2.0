import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';


# Prefix Array

A prefix array, also known as a prefix sum array or cumulative sum array, is an array where each element at an index stores the sum of all elements preceding it, including itself.

Prefix arrays are often used to efficiently compute cumulative sums for various ranges within the original array. 

#  Split Array Into Subarray With Equal Sum

This page offers detailed explanations and Java solutions for problems that involve splitting an array into subarrays with equal sums, using the Prefix Array technique.


## Split Array with Equal Sum

The problem description can be found at [Leetcode 548. Split Array with Equal Sum](https://leetcode.com/problems/split-array-with-equal-sum/description/).



### Explanation 



Let's take the sample input as below,

<br />
$$
\text{nums} = \begin{bmatrix}
1, 2, 1, 2, 1, 2, 1
\end{bmatrix}
$$
<br />


To solve this problem, we traverse through all array indices to establish the value for $j$. Inside the inner loop, we assign $i$ satisfying $0 < i < j$ and $k$ such that $j < k < $ nums.length.


Next, adjust the starting and maximum values for $i$, $j$, and $k$ to fit the conditions outlined in the question.

### Implementation
<Tabs>
  <TabItem value="Java" label="Java" default>

```java
import java.util.HashSet;

class Solution {
    public boolean splitArray(int[] nums) {
        int[] prefix = new int[nums.length];
        prefix[0] = nums[0];

        // Calculate prefix sums
        for (int i = 1; i < nums.length; i++) {
            prefix[i] = prefix[i - 1] + nums[i];
        }

        // Picking value of 'j'
        for (int middle = 3; middle < nums.length; middle++) {
            HashSet<Integer> set = new HashSet<>();

            // Picking value of 'i'
            for (int left = 1; left + 1 < middle; left++) {
                int first = sum(0, left - 1, prefix);
                int second = sum(left + 1, middle - 1, prefix);
                if (first == second) {
                    set.add(first);
                }
            }

            // Picking value of 'k'
            for (int right = middle + 2; right + 1 < nums.length; right++) {
                int third = sum(middle + 1, right - 1, prefix);
                int fourth = sum(right + 1, nums.length - 1, prefix);
                if (third == fourth && set.contains(third)) {
                    return true;
                }
            }
        }
        return false;
    }

    // Method to calculate sum within a range using prefix sums
    private int sum(int from, int to, int[] prefix) {
        return prefix[to] - (from - 1 > 0 ? prefix[from - 1] : 0);
    }
}
```
</TabItem>
</Tabs>

### Complexity 

Let's say there are $N$ elements in an array.

#### Time complexity 
$
O(N^2)
$

#### Space complexity
$
O(N)
$




<br />




## Similar questions

Here are some more questions that can be solved using the same technique.


### Sum Of Special Evenly-Spaced Elements In Array

The problem description can be found at [Leetcode 1714. Sum Of Special Evenly-Spaced Elements In Array](https://leetcode.com/problems/sum-of-special-evenly-spaced-elements-in-array/description/)


<details>
  <summary>Solution</summary>

<Tabs>
  <TabItem value="Java" label="Java" default>

```java
class Solution {
    private final int MOD = (int) 1e9 + 7;

    public int[] solve(int[] nums, int[][] queries) {
        int n = nums.length;

        // Precalculate the answer using the suffixArray technique.
        // For each step, suffixArray[step][from] represents 
				// the cumulative sum of elements
        // in the array when traversed backward, starting from the 'from' index
        // up to and including the 'from' index.
				// The cumulative sum is computed with a step size.
        // for e.g. for input array nums = [0,1,2,3,4,5,6,7]
        // suffixArray[1] will be [28, 28, 27, 25, 22, 18, 6, 7] 
				// taking 1 step before doing cumulative sum
        // suffixArray[2] will be [12, 16, 12, 15, 10, 12, 6, 7] 
				// taking 2 steps before doing cumulative sum
        int sqrt = (int) Math.sqrt(n);
        int[][] suffixArray = new int[sqrt + 1][n];
        for (int step = 1; step <= sqrt; step++) {
            for (int index = n - 1; index >= 0; index--) {
                suffixArray[step][index] = modAdd(
                        nums[index],
                        ((index + step < n) ? suffixArray[step][index + step] : 0)
                );
            }
        }

        int m = queries.length;
        int[] res = new int[m];
        for (int i = 0; i < m; i++) {
            int from = queries[i][0];
            int step = queries[i][1];

            // use pre-calculated answer if step is 
            // less than equal to square root of given array length
            if (step <= sqrt) {
                res[i] = suffixArray[step][from];
            }
            // else calculate the answer by running the for loop
            else {
                for (int index = from; index < n; index += step)
                    res[i] = modAdd(res[i], nums[index]);
            }
        }
        return res;
    }

    private int modAdd(int a, int b) {
        int res = (a + b);
        if (res < 0) res += MOD;
        return res % MOD;
    }
}
```
</TabItem>
</Tabs>
</details>
