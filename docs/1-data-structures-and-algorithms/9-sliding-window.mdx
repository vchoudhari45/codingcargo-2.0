import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Sliding Window

This page offers detailed explanations and Java solutions for problems, using the Sliding Window technique.

## Minimum Window Substring

The problem description can be found at [LeetCode 76. Minimum Window Substrings](https://leetcode.com/problems/minimum-window-substring/description/).


### Explanation 

This solution utilizes a sliding window approach to find the minimum window substring in string $s$ containing all characters from string $t$. 

It initializes a HashMap to track character frequencies, iterates through string $t$ to update the HashMap, and then uses two pointers, $\text{start}$ and $\text{end}$, to traverse string $s$. The $\text{end}$ pointer moves forward, updating the HashMap, and when a required character is found, the $\text{start}$ pointer is adjusted to minimize the window. 

The process continues until the end of string $s$, and the minimum window substring is returned.


### Implementation

<Tabs>
  <TabItem value="Java" label="Java" default>

```java
import java.util.HashMap;

public class Solution {

    // Finds the minimum window substring in string 's' 
    // containing all characters from string 't'.
    public String minWindow(String s, String t) {
        // initialize a HashMap to store character frequencies.
        HashMap<Character, Integer> map = new HashMap<>();
        int required = 0;

        // count the total number of required characters and update the HashMap.
        for (int i = 0; i < t.length(); i++) {
            char ch = t.charAt(i);
            required++;
            map.put(ch, map.getOrDefault(ch, 0) + 1);
        }

        int end = 0, start = 0, min = Integer.MAX_VALUE;
        String res = "";

        // move the 'end' pointer through string 's'.
        while (end < s.length()) {
            char ch = s.charAt(end++);

            // check if the current character is part of string 't'.
            if (map.containsKey(ch)) {
                map.put(ch, map.getOrDefault(ch, 0) - 1);
                if (map.get(ch) >= 0) required--;

                // check if the current window contains all required characters.
                while (start < end && required == 0) {
                    if (min > end - start) {
                        // Update minimum window and result.
                        min = end - start;
                        res = s.substring(start, end);
                    }

                    char chs = s.charAt(start++);

                    // update character frequency in the HashMap.
                    if (map.containsKey(chs)) 
                        map.put(chs, map.getOrDefault(chs, 0) + 1);

                    if (map.getOrDefault(chs, 0) > 0) required++;
                }
            }
        }

        // return the minimum window substring.
        return res;
    }
}
```
</TabItem>
</Tabs>








### Complexity 

Let's say there are $N$ characters in string $s$ and $M$ characters in string $t$.

#### Time complexity 
$
O(N)
$

#### Space complexity
$
O(M)
$

