# Redis Data Structures

This page provides an Introduction to Redis data Structures. These are my notes from the RU101 Redis University course.

## Redis Key 

A Redis key is a unique identifier used to store and retrieve data in a Redis database. Each key is associated with a value, and Redis supports various data types for values such as strings, lists, sets, hashes, and more.

Characteristics of a Key are as below:

	- Unique 
	- Binary Safe - Can be anything like simple string, number to binary value
	- Key names can be up $512\text{mb}$
	- Case Sensitive

Below are some commands that work for every data type of a Redis key.

#### SET 
	- Checks non-existence with NX 
	- Checks existence with XX 
	- Set expiration in miliseconds using PX 
	- Set expiration in seconds using EX

```java
SET key value [EX seconds] [PX miliseconds] [NX|XX]

SET customer:1000 fred
SET customer:1001 rick
OK
```


#### GET 

- Returns value associated with key 
- If the key does not exist, Redis returns (nil) or null

```java 
GET key 

GET customer:1000
"fred"
```

#### KEYS 
	- Blocks database until it iterates through all keys
	- Never use in Production
	- Useful for debugging


```java 
KEYS customer:1*
1) "customer:1001"
2) "customer:1000"
```


#### SCAN 
	- Blocks database but iterate over handful of keys at a time
	- Return the slot reference which you can use for subsequent call
	- May return 0 or more keys per call
  - Scan will return cursor value of $0$, when it has no more keys to iterate over

```java 
SCAN slot [MATCH Pattern][COUNT count]

SCAN 0 MATCH customer:1*
1) "0"
2) 1) "customer:1000"
```


#### DEL 
	- Deletes the key, and memory associated with it
	- Blocking Command

```java
DEL customer:1000
(integer) 1
```


#### UNLINK 
	- Unlinks the key, and memory associated with it is reclaimed by asynchronous process
	- Non Blocking Command 

```java
UNLINK customer:1001
(integer) 1
```


#### EXISTS 
	- Return $1$ if key exists or else returns $0$
```java
EXISTS customer:1001
(integer) 0
````

#### EXPIRE
Sets/Chages expiration on key

```java
EXPIRE key seconds

EXPIRE key timestamp 

PEXPIRE key milliseconds 

PEXPIREAT key milliseconds-timestamp
```


#### TTL 
Examines TTL for a key

```java 
TTL key 

PTTL Key 
```


#### PERSIST
TTL can be removed using PERSIST command. PERSIST will set the TTL to $-1$
```java
PERSIST key 
```

#### TYPE 
Return the type of the key
```java
TYPE customer:1000
string
```


#### OBJECT ENCODING 
Return the object encoding of the key
```java
OBJECT ENCODING user:23:visit-count
"int"
```

## Redis Data Types 

Redis supports several data types that allow you to store different kinds of data and work with them efficiently. Below are the main Redis data types:


### String 
	- Binary safe sequence of bytes 
	- String can store numerical values, serialized JSON
	- String can even store images, videos, documents and sounds
	- API response Caching is most common usecase

```java 
SET usage:63 '{"balance": 699.99, "currency": "USD", "tier": "Premium"}' EX 7200
```

Below are the commands that works on Redis String Data Types.

#### INCR 
If key doesn't exist it will create a new key with value $1$
```java
INCR user:23:visit-count 
```

#### INCRBY
```java
INCRBY user:23:credit-balance 30

INCRBY user:23:credit-balance -20
```

#### INCRBYFLOAT
```java
INCRBYFLOAT user:23:visit-count 0.1
```

### Hashes
	- It is collection of field value pair
	- Hashes are mutable
	- Stores field value as string, which means values will not have nested array or objects
	- All hashes commands takes $O(1)$ time, except `HGETALL` which takes $O(N)$ time where $N$ is number of fields in hash
	- Typical usecases are Rate Limiting, Session Cache

Below are the commands that works on Redis Hash Data Types.

#### HSET 
```java
HSET player:42 name abc level 4 hp 4 gold 20

HSET player:42 status 0
```

#### HEXISTS 
Returns $0$ if field doesn't exists else return $1$
```java
HEXISTS player:42 status
```

#### HDEL
```java
HDEL player:42 status
```

#### HGET
```java
HGET player:42 name
"abc"
```

#### HGETALL 
```java
HGETALL player:42
1) "name"
2) "abc"
3) "level"
4) "4"
5) "hp"
6) "4"
7) "gold"
8) "20"
```

#### HINCRBY 
```java
HINCRBY player:42 gold 120
```


### List
	- Ordered collection of Strings
	- Duplicates are allowed 
	- Elements can be added and removed at Left or Right
	- Elements can be inserted relative to another
	- Used to implement stack and queue
	- Usecases are activity stream, interprocess communication

Below are the commands that works on Redis List Data Types.

####  RPUSH/LPUSH 
```java
RPUSH playlist:user2 25
(integer) 1

RPUSH playlist:user2 71
(integer) 2
```

#### RPOP/LPOP 
```java
LPOP playlist:user2
"25"
```

#### LRANGE 
```java
LRANGE playlist:user2 0 4
1) "71"
```

#### LLEN 
```java
LLEN playlist:user2 
(integer) 1
```

### Set
	- Unordered collection of string 
	- Duplicates are not allowed 
	- Allows for difference, intersection and union set operations
	- Are not nested
	- Usescase are Unique Visitor


Below are the commands that works on Redis Set Data Types.

#### SADD 
```java
SADD player:online 42
(integer) 1

SADD player:31:friends 42
(integer) 1

SADD player:31:friends 43
(integer) 1
```

#### SCARD 
```java
SCARD player:online
(integer) 1
```

#### SISMEMBER 
```java
SISMEMBER player:online 42
(integer) 1
```

#### SINTER 
```java
SINTER player:31:friends player:online
1) "42"
```

#### SDIFF 
```java
SDIFF player:31:friends player:online
1) "43"
```

#### SREM 
```java
SREM player:31:friends 43
(integer) 1
```


### Sorted Set 
	- Ordered collection of unique members 
	- Each memeber has associated score
	- Support set operations like intersection, union and difference
	- Usecase are Priority Queue, Low Latency Leaderboards, Secondary Indexing


Below are the commands that works on Redis Sorted Set Data Types.

#### ZADD 
```java
ZADD key score memberId

ZADD leaders:exp 0 42 
(integer) 1
```

#### ZINCRBY 
```java
ZINCRBY leaders:exp 10 42
"10"
```

#### ZRANGE
```java
ZRANGE leaders:exp 0 9 WITHSCORES
1) "42"
2) "10"
```

## Attribute Search

Let's consider a scenario where we have events with specific attributes that we want to search based on certain criteria:

- Disabled Access Available: Yes/No
- Medal Event: Yes/No
- Event Venue: String

Example events
```java
{
	"sku": "123",
	"name": "Men's 100 m final",
	"disabled_access": True,
	"medal_event": True,
	"venue": "Olympic Stadium",
	"category": "Track & Field"
},
{
	"sku": "456",
	"name": "Women's 100 m final",
	"disabled_access": True,
	"medal_event": False,
	"venue": "Olympic Stadium",
	"category": "Track & Field"
},
{
	"sku": "789",
	"name": "Women's Judo final",
	"disabled_access": False,
	"medal_event": False,
	"venue": "Nippon Budokan",
	"category": "Track & Field"
}
```

Typical approach is to use secondary indexes or full text search like Solr and Lucene. Unlike many other databases, Redis does not support secondary indexes. Below are some of the techniques we can use to replicate secondary indexes features:

### Object Inspection

- Create a key for each event using the domain name `event` and a unique identifier called `sku`.
- Use SCAN to find all matching domain objects, retrieve each object using GET in our application code, and inspect them individually to verify if they meet the criteria.


```java

SET "event:123" "{\"sku\": \"123\", \"name\": \"Men's 100 m final\", \"disabled_access\": True, \"medal_event\": True, \"venue\": \"Olympic Stadium\", \"category\": \"Track & Field\"}"
OK 

SET "event:456" "{\"sku\": \"456\", \"name\": \"Women's 100 m final\", \"disabled_access\": True, \"medal_event\": False, \"venue\": \"Olympic Stadium\", \"category\": \"Track & Field\"}"
OK 

SET "event:789" "{\"sku\": \"789\", \"name\": \"Women's Judo final\", \"disabled_access\": False, \"medal_event\": False, \"venue\": \"Olympic Stadium\", \"category\": \"Track & Field\"}"
OK 
```

:::info
This approach is not ideal because it involves iterating over all the objects.
:::


### Faceted Search

 - Maintain a set for each attribute and value combination.
 - Next use SINTER to find matching SKU 

```java
SADD fs:disabled_access:True 123, 456
(integer) 2

SADD fs:disabled_access:False 789
(integer) 1

SADD fs:medal_event:True 123
(integer) 1

SADD fs:medal_event:False 456 789
(integer) 2

SADD fs:venue:"Olympic Stadium" 123 456
(integer) 2

SADD fs:venue:"Nippon Budokan" 789
(integer) 1

SINTER fs:disabled_access:True fs:medal_event:False
1) 456
```

### Hashed Index


