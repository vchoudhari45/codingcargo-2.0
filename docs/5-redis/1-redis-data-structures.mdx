# Redis Data Structures

This page provides an Introduction to Redis data Structures. These are my notes from the RU101 Redis University course.

## Redis Key 

A Redis key is a unique identifier used to store and retrieve data in a Redis database. Each key is associated with a value, and Redis supports various data types for values such as strings, lists, sets, hashes, and more.

Characteristics of a Key are as below:

	- Unique 
	- Binary Safe - Can be anything like simple string, number to binary value
	- Key names can be up 512mb
	- Case Sensitive

Below are some commands that work for every data type of a Redis key.

#### SET 
	- Checks non-existence with NX 
	- Checks existence with XX 
	- Set expiration in miliseconds using PX 
	- Set expiration in seconds using EX

```java
SET key value [EX seconds] [PX miliseconds] [NX|XX]

SET customer:1000 fred
SET customer:1001 rick
OK
```


#### GET 

- Returns value associated with key 
- If the key does not exist, Redis returns (nil) or null

```java 
GET key 

GET customer:1000
"fred"
```

#### KEYS 
	- Blocks database until it iterates through all keys
	- Never use in Production
	- Useful for debugging


```java 
KEYS customer:1*
1) "customer:1001"
2) "customer:1000"
```


#### SCAN 
	- Blocks database but iterate over handful of keys at a time
	- Return the slot reference which you can use for subsequent call
	- May return 0 or more keys per call
  - Scan will return cursor value of $0$, when it has no more keys to iterate over

```java 
SCAN slot [MATCH Pattern][COUNT count]

SCAN 0 MATCH customer:1*
1) "0"
2) 1) "customer:1000"
```


#### DEL 
	- Deletes the key, and memory associated with it
	- Blocking Command

```java
DEL customer:1000
(integer) 1
```


#### UNLINK 
	- Unlinks the key, and memory associated with it is reclaimed by asynchronous process
	- Non Blocking Command 
	- Unlink is preferred over Del command

```java
UNLINK customer:1001
(integer) 1
```


#### EXISTS 
	- Return $1$ if key exists or else returns $0$
```java
EXISTS customer:1001
(integer) 0
````

#### EXPIRE
Sets/Chages expiration on key

```java
EXPIRE key seconds

EXPIRE key timestamp 

PEXPIRE key milliseconds 

PEXPIREAT key milliseconds-timestamp
```


#### TTL 
Examines TTL for a key

```java 
TTL key 

PTTL Key 
```


#### PERSIST
TTL can be removed using PERSIST command. PERSIST will set the TTL to $-1$
```java
PERSIST key 
```

#### TYPE 
Return the type of the key
```java
TYPE customer:1000
string
```


#### OBJECT ENCODING 
Return the object encoding of the key
```java
OBJECT ENCODING user:23:visit-count
"int"
```

## Redis Data Types 

Redis supports several data types that allow you to store different kinds of data and work with them efficiently. Below are the main Redis data types:


### String 
	- Binary safe sequence of bytes 
	- String can store numerical values, serialized JSON
	- String can even store images, videos, documents and sounds
	- API response Caching is most common usecase

```java 
SET usage:63 '{"balance": 699.99, "currency": "USD", "tier": "Premium"}' EX 7200
```

Below are the commands that works on Redis String Data Types.

#### INCR 
If key doesn't exist it will create a new key with value $1$
```java
INCR user:23:visit-count 
```

#### INCRBY
```java
INCRBY user:23:credit-balance 30

INCRBY user:23:credit-balance -20
```

#### INCRBYFLOAT
```java
INCRBYFLOAT user:23:visit-count 0.1
```

### Hashes
	- It is collection of field value pair
	- Hashes are mutable
	- Stores field value as string, which means values will not have nested array or objects
	- All hashes commands takes $O(1)$ time, except `HGETALL` which takes $O(N)$ time where $N$ is number of fields in hash
	- Typical usecases are Rate Limiting, Session Cache

Below are the commands that works on Redis Hash Data Types.

#### HSET 
```java
HSET player:42 name abc level 4 hp 4 gold 20
(integer) 4

HSET player:42 status 0
(integer) 1
```

#### HEXISTS 
Returns $0$ if field doesn't exists else return $1$
```java
HEXISTS player:42 status
(integer) 1
```

#### HDEL
```java
HDEL player:42 status
(integer) 1
```

#### HGET
```java
HGET player:42 name
"abc"
```

#### HGETALL 
```java
HGETALL player:42
1) "name"
2) "abc"
3) "level"
4) "4"
5) "hp"
6) "4"
7) "gold"
8) "20"
```

#### HINCRBY 
```java
HINCRBY player:42 gold 120
(integer) 140
```

#### HINCRBYFLOAT
```java
HINCRBYFLOAT player:42 gold 120
"260"
```

#### HSCAN
```java
HSCAN player:42 0 match l*
1) "0"
2) 1) "level"
   2) "4"
```


### List
	- Ordered collection of Strings
	- Duplicates are allowed 
	- Elements can be added and removed at Left or Right
	- Elements can be inserted relative to another
	- Used to implement stack and queue
	- Usecases are activity stream, interprocess communication

Below are the commands that works on Redis List Data Types.

####  RPUSH/LPUSH 
```java
RPUSH playlist:user2 25
(integer) 1

RPUSH playlist:user2 71
(integer) 2
```

#### RPOP/LPOP 
```java
LPOP playlist:user2
"25"
```

#### LRANGE 
```java
LRANGE playlist:user2 0 4
1) "71"
```

#### LLEN 
```java
LLEN playlist:user2 
(integer) 1
```

### Set
	- Unordered collection of string 
	- Duplicates are not allowed 
	- Allows for difference, intersection and union set operations
	- Are not nested
	- Usescase are Unique Visitor


Below are the commands that works on Redis Set Data Types.

#### SADD 
```java
SADD player:online 42
(integer) 1

SADD player:31:friends 42
(integer) 1

SADD player:31:friends 43
(integer) 1
```

#### SCARD 
```java
SCARD player:online
(integer) 1
```

#### SISMEMBER 
```java
SISMEMBER player:online 42
(integer) 1
```

#### SMEMBERS 
```java
SMEMBERS player:online 
1) "42"
```

#### SINTER 
```java
SINTER player:31:friends player:online
1) "42"
```

#### SDIFF 
```java
SDIFF player:31:friends player:online
1) "43"
```

#### SREM 
```java
SREM player:31:friends 43
(integer) 1
```


### Sorted Set 
	- Ordered collection of unique members 
	- Each memeber has associated score
	- Support set operations like intersection, union and difference
	- Usecase are Priority Queue, Low Latency Leaderboards, Secondary Indexing


Below are the commands that works on Redis Sorted Set Data Types.

#### ZADD 
```java
ZADD key score memberId

ZADD leaders:exp 0 42 
(integer) 1
```

#### ZINCRBY 
```java
ZINCRBY leaders:exp 10 42
"10"
```

#### ZRANGE
```java
ZRANGE leaders:exp 0 9 WITHSCORES
1) "42"
2) "10"
```

## Attribute Search

Let's consider a scenario where we have events with specific attributes that we want to search based on certain criteria:

- Disabled Access Available: Yes/No
- Medal Event: Yes/No
- Event Venue: String

Example events
```json
{
  "sku": "123",
  "name": "Men's 100 m final",
  "disabled_access": True,
  "medal_event": True,
  "venue": "Olympic Stadium",
  "category": "Track & Field"
},
{
  "sku": "456",
  "name": "Women's 100 m final",
  "disabled_access": True,
  "medal_event": False,
  "venue": "Olympic Stadium",
  "category": "Track & Field"
},
{
  "sku": "789",
  "name": "Women's Judo final",
  "disabled_access": False,
  "medal_event": False,
  "venue": "Nippon Budokan",
  "category": "Track & Field"
}
```

Typical approach is to use secondary indexes or full text search like Solr and Lucene. Unlike many other databases, Redis does not support secondary indexes. Below are some of the techniques we can use to replicate secondary indexes features:

### Object Inspection

- Create a key for each event using the domain name `event` and a unique identifier called `sku`.
- Use SCAN to find all matching domain objects, retrieve each object using GET in our application code, and inspect them individually to verify if they meet the criteria.


```java
SET "event:123" "{\"sku\": \"123\", \"name\": \"Men's 100 m final\", \"disabled_access\": True, \"medal_event\": True, \"venue\": \"Olympic Stadium\", \"category\": \"Track & Field\"}"
OK 

SET "event:456" "{\"sku\": \"456\", \"name\": \"Women's 100 m final\", \"disabled_access\": True, \"medal_event\": False, \"venue\": \"Olympic Stadium\", \"category\": \"Track & Field\"}"
OK 

SET "event:789" "{\"sku\": \"789\", \"name\": \"Women's Judo final\", \"disabled_access\": False, \"medal_event\": False, \"venue\": \"Olympic Stadium\", \"category\": \"Track & Field\"}"
OK 
```

:::info
This approach is not ideal because it involves iterating over all the objects.
:::


### Faceted Search

 - Maintain a set for each attribute and value combination.
 - Next use SINTER to find matching SKU 

```java
SADD fs:disabled_access:True 123, 456
(integer) 2

SADD fs:disabled_access:False 789
(integer) 1

SADD fs:medal_event:True 123
(integer) 1

SADD fs:medal_event:False 456 789
(integer) 2

SADD fs:venue:"Olympic Stadium" 123 456
(integer) 2

SADD fs:venue:"Nippon Budokan" 789
(integer) 1

SINTER fs:disabled_access:True fs:medal_event:False
1) 456
```

### Hashed Index

- Create a hash for each attribute combination similar to compound index in relations databases
- Search for matching SKU by looking up hash

```java
# md5 of "disabled_access: True" = 28ae1a76ed0dbf9062313f6b8038aab6
SADD hfs:28ae1a76ed0dbf9062313f6b8038aab6 123 456

# md5 of "disabled_access: True, medal_event: False" = f5874c6fb98365760e78503458262718
SADD hfs:f5874c6fb98365760e78503458262718 456

# search for "disabled_access: True, medal_event: False" 
SMEMBERS hfs:f5874c6fb98365760e78503458262718
1) "123"
2) "456"
```

## Redis Transactions

Redis transactions ensure that all commands in a transaction are serialized and executed sequentially, ensuring isolation and atomicity. Commands queued during a transaction are isolated and private. Other sessions cannot see the changes until the transaction is executed.

Redis does not support nested transactions because commands are queued instead of immediately executed, reducing the need for nested operations.

Below are the commands used to control transactions in Redis

#### MULTI

Starts the transaction, queuing up subsequent commands for execution.

#### EXEC

Executes the queued commands.

#### DISCARD

Discards the queued commands.

Below is an example flow for the transaction

<b> Client 1</b>: Sets a key event:Judo to "Sold Out".

```java
SET event:Judo "Sold Out"
OK
```

<b> Client 2</b>: Starts a transaction using MULTI and queues commands (SET and INCR), but these commands are not executed immediately.

```java
MULTI
OK 

SET event:Judo 100
QUEUED

INCR event:Judo
QUEUED
```

<b> Client 1</b>: Performs a GET operation, still seeing the value "Sold Out" since client 2's commands are only queued.

```java
GET event:Judo
"Sold Out"
```

<b> Client 2</b>: Queues a GET command, which is also not executed immediately.

```java
GET event:Judo
```

<b> Client 2</b>: Executes EXEC, the queued commands are executed as a batch, changing the value of the key from 100 to 101. The final GET command returns 101.

```java
EXEC
1) OK
2) (integer) 101
3) "101"
```

<b> Client 1</b>: Performs a GET operation, and will see updated value.

```java
GET event:Judo
101
```

### Handling Errors 

- If an invalid command is queued, Redis marks the transaction as invalid, and none of the commands will be executed upon EXEC.

-  If a valid command causes a failure, like performing INCR on a list data type, Redis will continue executing the remaining commands.

- Redis does not support rollback to optimize performance. Programming errors should be addressed in pre-production cycles.


## Optimistic Concurrency Control

Optimistic locking or optimistic concurrency control is a mechanism that allows you to specify an interest in an object and get a notification if that object has changed. Keyspace notifications is the mechanism that can be used in Redis to satisfy this need. 

Below are the commands for implmenting optimistic concurrency control in Redis.

#### WATCH 

WATCH is used to declare interest in one or more keys. When EXEC is called the transaction will fail if any watched keys have been modified. 

WATCH has to be called before the transaction is started, so you need to decide upfront the keys that need to be observed. Multiple WATCH commands can be executed before the MULTI. The effects are cumulative. Subsequent WATCH commands do not override previous keys being watched.

Watches are also local to the current client and connection. They are not global in scope. Only clients with the watch on a specific key will fail. 


#### UNWATCH 

UNWATCH is used to remove all watch keys. If a transaction is successfully completed with EXEC then all keys are automatically unwatched. You do not need to explicitly unwatch the keys in your code after a successful transaction.


### Successful Transaction

Below is an example of successful transaction scenario using WATCH and UNWATCH.

<b>Client 1</b>: Watches the key event:Judo with a value of 200

```java
WATCH event:Judo
OK
```

<b>Client 1</b>: starts a transaction, modifies the key to 101, and calls EXEC.

```java
MULTI
OK

SET event:Judo 101
QUEUED

GET event:Judo
"101"
```

Since the key has not been modified by another client, the transaction succeeds, and the key is set to 101.


### Unsuccessful Transaction

Below is an example of unsuccessful transaction scenario using WATCH and UNWATCH.

<b>Client 1</b>: watches the key event:Judo and starts a transaction to increment its value.

```java
WATCH event:Judo
OK

MULTI
OK

INCR event:Judo
QUEUED
```

<b>Client 2</b>: Changes the key value to 100 by decrementing it.

```java
DECR event:Judo
(integer) 100
```

<b>Client 1</b>: Calls EXEC, which fails with a nil response because the watched key has been modified. The transaction is discarded.

```java
EXEC
(nil)
```

## Storing Nested JSON

Here is example of Nested JSON 

```json
{
  "sku": "123",
  "name": "Men's final",
  "disabled_access": True,
  "medal_event": True,
  "available": {
    "general": {
      "qty": 100,
      "price": 25
    },
    "vip": {
      "qty": 10,
      "price": 500
    }
  }
}
```

### Storing in Hashes

#### Pros
- Provides encapsulation.
- Commands in Redis are atomic.
- Multiple fields can be manipulated in a single request without a transaction.
- When a key is removed, all related data is also removed, this is equivalent to a CASCADE DELETE on a foreign key in a relational database.


#### Cons
- Hashes get larger with large objects.

```java
HMSET sku:123 name "Men's final" disabled_access True medal_event True
OK

HMSET sku:123 available:general:qty 100 available:general:price 25 
OK

HMSET sku:123 available:vip:qty 10 available:vip:price 500 
OK

# Retrieves data using HGETALL and SCAN commands
HGETALL sku:123
 1) "name"
 2) "Men's final"
 3) "disabled_access"
 4) "True"
 5) "medal_event"
 6) "True"
 7) "available:general:qty"
 8) "100"
 9) "available:general:price"
10) "25"
11) "available:vip:qty"
12) "10"
13) "available:vip:price"
14) "500"

HSCAN sku:123 0 match available*
1) "0"
2) 1) "available:general:qty"
   2) "100"
   3) "available:general:price"
   4) "25"
   5) "available:vip:qty"
   6) "10"
   7) "available:vip:price"
   8) "500"
```

