import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';



#  Split Array Into K Subarrays

This page features a list of links to explanations and Java solutions for problems that involve splitting an array into $K$ subarrays, using the Binary Search technique.


## How to Spot These Problems

You can identify such problems if the it asks you to split the array into $K$ subarrays to satisfy a specific condition.


## Leetcode Problem Set

[LeetCode 410. Split Array Largest Sum](/leetcode/split-array-largest-sum/)

[Leetcode 1231. Divide Chocolate](/leetcode/divide-chocolate/)

## Similar questions

Here are some more questions that can be solved using the same technique.

### Divide Chocolate

The problem description can be found at [Leetcode 1231. Divide Chocolate](https://leetcode.com/problems/divide-chocolate/).


<details>
  <summary>Solution</summary>

<Tabs>
  <TabItem value="Java" label="Java" default>

```java
class Solution {
    public int maximizeSweetness(int[] sweetness, int k) {
        // Initialize the lower bound `lo` and the upper bound `hi`
        int lo = Integer.MAX_VALUE;
        int hi = 0;

        // Determine the bounds for the binary search
        for (int i = 0; i < sweetness.length; i++) {
            lo = Math.min(lo, sweetness[i]);
            hi += sweetness[i];
        }

        // Increment `k` by 1 (because questions say excluding you there k members)
        k++;

        // Binary search to find the maximum sweetness value
        while (lo < hi) {
            int mid = (lo + hi + 1) / 2; // Calculate the middle value

            // Get the number of partitions
            int partitions = getPartitions(sweetness, mid); 

            // Adjust bounds based on the number of partitions
            if (partitions < k)
                hi = mid - 1;
            else
                lo = mid;
        }

        return lo; 
    }

    /**
     * Method to calculate the number of partitions achievable 
     * based on a sweetness threshold
     */
    private int getPartitions(int[] nums, int required) {
        int index = 0, sum = 0, partitions = 0;

        // Iterate through the sweetness array and count the partitions
        while (index < nums.length) {
            sum += nums[index];

            // Check if the current sum meets the required sweetness threshold
            if (sum >= required) {
                sum = 0; // Reset sum for the next partition
                partitions++; // Increment partitions count
            }

            index++; // Move to the next sweetness value
        }

        return partitions; 
    }
}
```
</TabItem>
</Tabs>
</details>

:::info[]
Notice how we use $\text{mid} = (\text{lo} + \text{hi} + 1) / 2$ in our solution because once $\text{mid}$ satisfies the condition, \
we set $\text{lo} = \text{mid}$ to keep $\text{mid}$ within the search range. This matters if we ever reach a scenario where \
$\text{hi} - \text{lo} = 1$.

For example,
lets say we have $\text{lo} = 2$ and $\text{hi} = 3$ we get $\text{mid} = 2$, if we use $\text{mid} = (\text{lo} + \text{hi}) / 2$.
Now if $2$ satisfies the condition and we assign $\text{lo} = \text{mid}$, binary search keeps all the values same for the next iteration, causing the logic to run endlessly.
:::








<br />

### Cutting Ribbons

The problem description can be found at [LeetCode 1891. Cutting Ribbons](https://leetcode.com/problems/cutting-ribbons/).


<details>
  <summary>Solution</summary>

<Tabs>
  <TabItem value="Java" label="Java" default>

```java
class Solution {
    public int maxLength(int[] ribbons, int k) {
        int lo = 0;
        int hi = Integer.MIN_VALUE;
        for(int i = 0; i < ribbons.length; i++) {
            hi = Math.max(ribbons[i], hi);
        }

        while(lo < hi) {
            int mid = (lo + hi + 1) / 2;
            int partitions = getPartitions(ribbons, mid);
            if(partitions >= k) lo = mid;
            else hi = mid - 1;
        }
        return lo;
    }

    private int getPartitions(int[] ribbons, int required) {
        int partitions = 0;
        for(int i = 0; i < ribbons.length; i++) {
            partitions += ribbons[i] / required;
        }
        return partitions;
    }
}
```
</TabItem>
</Tabs>
</details>









<br />

### Capacity To Ship Packages Within D Days

The problem description can be found at [LeetCode 1011. Capacity To Ship Packages Within D Days](https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/)


<details>
  <summary>Solution</summary>

<Tabs>
  <TabItem value="Java" label="Java" default>

```java
class Solution {
    public int shipWithinDays(int[] weights, int days) {
        int lo = Integer.MIN_VALUE;
        int hi = 0;

        // Determine the bounds for the binary search
        for (int weight : weights) {
            lo = Math.max(lo, weight); d
            hi += weight; 
        }

        // Perform binary search to find the minimum capacity
        while (lo < hi) {
            int mid = lo + (hi - lo) / 2;
            // Check if more days are required
            boolean isMoreDays = daysRequired(weights, mid, days); 
            if (isMoreDays)
                lo = mid + 1; 
            else
                hi = mid; 
        }
        return lo; // Return the minimum capacity
    }

    // Helper function to check if more days are required based on the capacity
    private boolean daysRequired(int[] weights, int capacity, int days) {
        int requiredDays = 1, index = 0, sum = 0;

        // Iterate through the weights to determine the required days
        while (index < weights.length) {
            sum += weights[index]; // Accumulate the sum of weights
            if (sum > capacity) {
                sum = weights[index]; // Reset the sum for a new day
                requiredDays++; // Increment the required days
            }
            index++; // Move to the next weight

            if (requiredDays > days)
                return true; // If required days exceed the given limit
        }
        return false; // If required days are within the given limit
    }
}	
```
</TabItem>
</Tabs>
</details>










<br />

### Minimized Maximum of Products Distributed to Any Store

The problem description can be found at [LeetCode 2064. Minimized Maximum of Products Distributed to Any Store](https://leetcode.com/problems/minimized-maximum-of-products-distributed-to-any-store)

<details>
  <summary>Solution</summary>

<Tabs>
  <TabItem value="Java" label="Java" default>

```java
class Solution {
    public int minimizedMaximum(int n, int[] quantities) {
        int lo = 1;
        int hi = Integer.MIN_VALUE;
        for(int i = 0; i < quantities.length; i++) {
            hi = Math.max(hi, quantities[i]);
        }

        while(lo < hi) {
            int mid = (lo + hi) / 2;
            int partitions = getPartitions(quantities, mid);
            if(partitions > n) lo = mid + 1;
            else hi = mid;
        }
        return lo;
    }

    private int getPartitions(int[] quantities, int required) {
        int partitions = 0;
        for(int i = 0; i < quantities.length; i++) {
            partitions += quantities[i] / required;
            if(quantities[i] % required != 0) 
                partitions++;           
        }
        return partitions;
    }
}
```
</TabItem>
</Tabs>
</details>







<br />

### Distribute Money to Maximum Children

The problem description can be found at [LeetCode 2591. Distribute Money to Maximum Children](https://leetcode.com/problems/distribute-money-to-maximum-children/)


<details>
  <summary>Solution</summary>

<Tabs>
  <TabItem value="Java" label="Java" default>

```java
class Solution {
    public int distMoney(int money, int children) {
        int lo = -1;
        int hi = children;
        while(lo < hi) {
            int mid = (lo + hi + 1) / 2;
            if(isValid(money, mid, children)) lo = mid;
            else hi = mid - 1;
        }
        return lo;
    }

    private boolean isValid(int money, int maxChlidren, int children) {
        int remainingMoney = money - 8 * maxChlidren;
        int remainingChildren = children - maxChlidren;
        if(remainingMoney == 4 && remainingChildren == 1) return false;
        else if(remainingMoney < remainingChildren) return false;
        else if(remainingMoney > 0 && remainingChildren == 0) return false;
        else return true;
    }
}
```
</TabItem>
</Tabs>
</details>






