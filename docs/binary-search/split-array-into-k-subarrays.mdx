import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';



#  Split Array Into K Subarrays

This page provides links to solutions for problems that involve splitting an array into $K$ subarrays using the Binary Search technique.


## How to Spot These Problems

You can identify such problems if they ask you to split an array into $K$ subarrays to satisfy a specific condition.

## Leetcode Problem Set

[LeetCode 410. Split Array Largest Sum](/leetcode/split-array-largest-sum/)

[Leetcode 1231. Divide Chocolate](/leetcode/divide-chocolate/)

[Leetcode 1891. Cutting Ribbons](/leetcode/cutting-ribbons/)


### Cutting Ribbons

The problem description can be found at [LeetCode 1891. Cutting Ribbons](https://leetcode.com/problems/cutting-ribbons/).


<details>
  <summary>Solution</summary>

<Tabs>
  <TabItem value="Java" label="Java" default>

```java
class Solution {
    public int maxLength(int[] ribbons, int k) {
        int lo = 0;
        int hi = Integer.MIN_VALUE;
        for(int i = 0; i < ribbons.length; i++) {
            hi = Math.max(ribbons[i], hi);
        }

        while(lo < hi) {
            int mid = (lo + hi + 1) / 2;
            int partitions = getPartitions(ribbons, mid);
            if(partitions >= k) lo = mid;
            else hi = mid - 1;
        }
        return lo;
    }

    private int getPartitions(int[] ribbons, int required) {
        int partitions = 0;
        for(int i = 0; i < ribbons.length; i++) {
            partitions += ribbons[i] / required;
        }
        return partitions;
    }
}
```
</TabItem>
</Tabs>
</details>









<br />

### Capacity To Ship Packages Within D Days

The problem description can be found at [LeetCode 1011. Capacity To Ship Packages Within D Days](https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/)


<details>
  <summary>Solution</summary>

<Tabs>
  <TabItem value="Java" label="Java" default>

```java
class Solution {
    public int shipWithinDays(int[] weights, int days) {
        int lo = Integer.MIN_VALUE;
        int hi = 0;

        // Determine the bounds for the binary search
        for (int weight : weights) {
            lo = Math.max(lo, weight); d
            hi += weight; 
        }

        // Perform binary search to find the minimum capacity
        while (lo < hi) {
            int mid = lo + (hi - lo) / 2;
            // Check if more days are required
            boolean isMoreDays = daysRequired(weights, mid, days); 
            if (isMoreDays)
                lo = mid + 1; 
            else
                hi = mid; 
        }
        return lo; // Return the minimum capacity
    }

    // Helper function to check if more days are required based on the capacity
    private boolean daysRequired(int[] weights, int capacity, int days) {
        int requiredDays = 1, index = 0, sum = 0;

        // Iterate through the weights to determine the required days
        while (index < weights.length) {
            sum += weights[index]; // Accumulate the sum of weights
            if (sum > capacity) {
                sum = weights[index]; // Reset the sum for a new day
                requiredDays++; // Increment the required days
            }
            index++; // Move to the next weight

            if (requiredDays > days)
                return true; // If required days exceed the given limit
        }
        return false; // If required days are within the given limit
    }
}	
```
</TabItem>
</Tabs>
</details>










<br />

### Minimized Maximum of Products Distributed to Any Store

The problem description can be found at [LeetCode 2064. Minimized Maximum of Products Distributed to Any Store](https://leetcode.com/problems/minimized-maximum-of-products-distributed-to-any-store)

<details>
  <summary>Solution</summary>

<Tabs>
  <TabItem value="Java" label="Java" default>

```java
class Solution {
    public int minimizedMaximum(int n, int[] quantities) {
        int lo = 1;
        int hi = Integer.MIN_VALUE;
        for(int i = 0; i < quantities.length; i++) {
            hi = Math.max(hi, quantities[i]);
        }

        while(lo < hi) {
            int mid = (lo + hi) / 2;
            int partitions = getPartitions(quantities, mid);
            if(partitions > n) lo = mid + 1;
            else hi = mid;
        }
        return lo;
    }

    private int getPartitions(int[] quantities, int required) {
        int partitions = 0;
        for(int i = 0; i < quantities.length; i++) {
            partitions += quantities[i] / required;
            if(quantities[i] % required != 0) 
                partitions++;           
        }
        return partitions;
    }
}
```
</TabItem>
</Tabs>
</details>







<br />

### Distribute Money to Maximum Children

The problem description can be found at [LeetCode 2591. Distribute Money to Maximum Children](https://leetcode.com/problems/distribute-money-to-maximum-children/)


<details>
  <summary>Solution</summary>

<Tabs>
  <TabItem value="Java" label="Java" default>

```java
class Solution {
    public int distMoney(int money, int children) {
        int lo = -1;
        int hi = children;
        while(lo < hi) {
            int mid = (lo + hi + 1) / 2;
            if(isValid(money, mid, children)) lo = mid;
            else hi = mid - 1;
        }
        return lo;
    }

    private boolean isValid(int money, int maxChlidren, int children) {
        int remainingMoney = money - 8 * maxChlidren;
        int remainingChildren = children - maxChlidren;
        if(remainingMoney == 4 && remainingChildren == 1) return false;
        else if(remainingMoney < remainingChildren) return false;
        else if(remainingMoney > 0 && remainingChildren == 0) return false;
        else return true;
    }
}
```
</TabItem>
</Tabs>
</details>






