
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';



# Partition Array Into K Subarrays


This page offers detailed explanations and Java solutions for problems that involve partitioning an array into $K$ subarrays, using the Backtracking technique.


## Fair Distribution of Cookies

The problem description can be found at [Leetcode 2305. Fair Distribution of Cookies](https://leetcode.com/problems/fair-distribution-of-cookies/description/).




### Explanation 
Some problems simply call for a basic backtracking method to solve them. You can spot these by considering \
the size of the input. Another clue is that the problem requires checking all possible outcomes before arriving \
at the expected solution.


Let's take the sample input as below,

<br />
$$
\text{cookies} = \begin{bmatrix}
6, 1, 3, 2, 2, 4, 1, 2
\end{bmatrix}, 
\  \text{k} = 3
$$
<br />


:::info
Because the task involves distributing the array rather than splitting it, the binary search algorithm isn't \
suitable for this problem.
:::

<br />

Backtracking involves solving problems by progressively constructing potential solutions, so let's start by \
assigning the first bag of cookies to each child one by one, then proceed to the second, third, and so forth.








Let's visualize the distribution of cookie bags $P$, $Q$, and $R$ among $2$ children.

<br />
<div style={{textAlign:"center"}}>

```mermaid
graph TD
    A((&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Root &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)) --Assign bag P--> B((&nbsp; Child 1: P &nbsp;))
    A((&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Root &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)) --Assign bag P--> C((&nbsp; Child 2: P &nbsp;))

		B --Assign bag Q--> D((&nbsp; Child 1: P, Q &nbsp;))
    B --Assign bag Q--> E((&nbsp;&nbsp;&nbsp; Child 1: P  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \n Child 2: Q &nbsp))
		
		C --Assign bag Q--> F((&nbsp; Child 2: P, Q &nbsp;))
		C --Assign bag Q--> G((&nbsp;&nbsp;&nbsp; Child 1: Q  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \n Child 2: P &nbsp))

	  D --Assign bag R--> H((&nbsp; Child 1: P, Q, R &nbsp;))
    E --Assign bag R--> I((&nbsp;&nbsp;&nbsp; Child 1: P  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \n Child 2: Q, R &nbsp))
		F --Assign bag R--> J((&nbsp; Child 2: P, Q, R &nbsp;))
		G --Assign bag R--> K((&nbsp;&nbsp;&nbsp;&nbsp; Child 1: Q, R &nbsp;&nbsp; \n Child 2: P &nbsp))
```
</div>
<br />






### Implementation
<Tabs>
  <TabItem value="Java" label="Java" default>

```java
class Solution {
    private int min = Integer.MAX_VALUE;

    public int distributeCookies(int[] cookies, int k) {
        backtrack(cookies, 0, new int[k]);
        return min;
    }

    // Backtracking method to find the minimum of maximum value
    private void backtrack(int[] cookies, int index, int[] dist) {
        // Base case: all cookies are distributed
        if (index == cookies.length) {
            min = Math.min(min, max(dist));
        } else {
            // Try distributing the current cookie to each child 
            // and find the minimum value
            for (int i = 0; i < dist.length; i++) {
                // If the current distribution is the same as the previous 
                // distribution then discard this distribution
                if (i > 0 && dist[i] == dist[i - 1]) continue;

                // If the distribution already exceeds the previously found min, 
                // then discard this distribution
                if (dist[i] + cookies[index] >= min) continue;

                dist[i] += cookies[index]; // Distribute cookie to child i
                backtrack(cookies, index + 1, dist);
                dist[i] -= cookies[index]; // Backtrack: remove the distributed cookie
            }
        }
    }

    // Method to find the maximum value in a distribution
    private int max(int[] dist) {
        int maxValue = Integer.MIN_VALUE;
        // Find the maximum value in the distribution
        for (int i = 0; i < dist.length; i++) {
            maxValue = Math.max(maxValue, dist[i]);
        }
        return maxValue;
    }
}
```
</TabItem>
</Tabs>









### Complexity 

Let's say there are $N$ bags of cookies to distribute among $K$ children.

#### Time complexity 
$
O(K ^ N)
$

#### Space complexity
$
O(K + N)
$










<br />

## Similar questions

Here are some more questions that can be solved using the same technique.


### Probability of a Two Boxes Having The Same Number of Distinct Balls

The problem description can be found at [Leetcode 1467. Probability of a Two Boxes Having The Same Number of Distinct Balls](https://leetcode.com/problems/probability-of-a-two-boxes-having-the-same-number-of-distinct-balls/description/).


<details>
  <summary>Solution</summary>

<Tabs>
  <TabItem value="Java" label="Java" default>

```java
class Solution {
    double[] factorial = new double[49]; // Array to store factorials

    // Main method to calculate probability
    public double getProbability(int[] balls) {
        int sum = 0;
        // Calculate total number of balls
        for (int i = 0; i < balls.length; i++) {
            sum += balls[i];
        }

        // Calculate factorials for later use
        factorial[0] = 1;
        for (int i = 1; i < 49; i++) {
            factorial[i] = factorial[i - 1] * i;
        }

        double valid = backtrack(balls, 0, 0, 0, 0, 0); // Calculate valid cases
        double total = combinations(sum, sum / 2); // Calculate total combinations

        return valid / total; // Return probability
    }

    // Backtracking method to calculate valid cases
    private double backtrack(int[] balls, int index, int box1Color, int box2Color,
                             int box1Count, int box2Count) {
        if (index == balls.length) {
            // Check if counts and colors match for both boxes
            return box1Count == box2Count && box1Color == box2Color ? 1 : 0;
        } else {
            double res = 0;
            for (int i = 0; i <= balls[index]; i++) {
                double combinations = combinations(balls[index], i);
                res += combinations * backtrack(
                        balls, index + 1,
                        i > 0 ? box1Color + 1 : box1Color,
                        i < balls[index] ? box2Color + 1 : box2Color,
                        box1Count + i,
                        box2Count + (balls[index] - i)
                );
            }
            return res;
        }
    }

    // Method to calculate combinations using factorials
    private double combinations(int n, int r) {
        return factorial[n] / factorial[n - r] / factorial[r];
    }
}
```
</TabItem>
</Tabs>
</details>




###  Find Minimum Time to Finish All Jobs

The problem description can be found at [Leetcode 1723. Find Minimum Time to Finish All Jobs](https://leetcode.com/problems/find-minimum-time-to-finish-all-jobs/description/).


<details>
  <summary>Solution</summary>

<Tabs>
  <TabItem value="Java" label="Java" default>

```java
class Solution {
    private int min = Integer.MAX_VALUE;

    // Main method to calculate minimum time required
    public int minimumTimeRequired(int[] jobs, int k) {
        backtrack(jobs, 0, new int[k]);
        return min;
    }

    // Backtracking method to find the minimum of maximum value
    private void backtrack(int[] jobs, int index, int[] workers) {
        // Base case: all jobs are assigned
        if (index == jobs.length) {
            min = Math.min(min, max(workers));
        } else {
            // Try assigning the current job to each worker and find the minimum value
            for (int i = 0; i < workers.length; i++) {
                // If the current assignment is the same as the previous one, skip
                if (i > 0 && workers[i] == workers[i - 1]) continue;

                // If the current assignment exceeds the previously found min, then discard
                if (workers[i] + jobs[index] > min) continue;

                workers[i] += jobs[index]; // Assign job to worker i
                backtrack(jobs, index + 1, workers);
                workers[i] -= jobs[index]; // Backtrack: remove the assigned job
            }
        }
    }

    // Method to find the maximum value in an array
    private int max(int[] array) {
        int maxValue = Integer.MIN_VALUE;
        // Find the maximum value in the array
        for (int i = 0; i < array.length; i++) {
            maxValue = Math.max(maxValue, array[i]);
        }
        return maxValue;
    }
}
```
</TabItem>
</Tabs>
</details>








