
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';



# Partition Array Into K Subarrays


This page offers detailed explanations and Java solutions for problems that involve partitioning an array into $K$ subarrays, using the Backtracking technique.


## Fair Distribution of Cookies

The problem description can be found at [Leetcode 2305. Fair Distribution of Cookies](https://leetcode.com/problems/fair-distribution-of-cookies/description/).




### Explanation 
Some problems simply call for a basic backtracking method to solve them. You can spot these by looking at the \
the size of the input. Another clue is that the problem requires checking all possible outcomes before arriving \
at the expected solution.


Let's take the sample input as below,

<br />
$$
\text{cookies} = \begin{bmatrix}
6, 1, 3, 2, 2, 4, 1, 2
\end{bmatrix}, 
\  \text{k} = 3
$$
<br />


:::info
Because the task involves distributing the array rather than splitting it, the binary search algorithm isn't \
suitable for this problem.
:::

<br />

Backtracking involves solving problems by progressively constructing potential solutions, so let's start by \
assigning the first bag of cookies to each child one by one, then proceed to the second, third, and so forth.








Let's visualize the distribution of cookie bags $P$, $Q$, and $R$ among $2$ children, $C1$ & $C2$.

<br />
<div style={{textAlign:"center"}}>

```mermaid
graph TD
    A([Start]) -->|Bag P to C1| B([C1: P])
    A -->|Bag P to C2| C([C2: P])
	
    B -->|Bag Q to C1| D([C1: P, Q])
    B -->|Bag Q to C2| E([C1: P<br/>C2: Q])

    C -->|Bag Q to C1| F([C1: Q<br/>C2: P])
    C -->|Bag Q to C2| G([C2: P, Q])

    D -->|Bag R to C1| H([C1: P, Q, R])
		D -->|Bag R to C2| I([C1: P, Q<br/> C2: R])

    E -->|Bag R to C1| J([C1: P, R<br/>C2: Q])
		E -->|Bag R to C2| K([C1: P<br/>C2: Q, R])

    F -->|Bag R to C1| N([C1: Q, R<br/>C2: P])
		F -->|Bag R to C2| O([C1: Q<br/>C2: P, R])

		G -->|Bag R to C1| L([C1: R<br/>C2: P, Q])
		G -->|Bag R to C2| M([C2: P, Q, R])
``` 
</div>
<br />






### Implementation
<Tabs>
  <TabItem value="Java" label="Java" default>

```java
class Solution {
    private int min = Integer.MAX_VALUE;

    public int distributeCookies(int[] cookies, int k) {
        backtrack(cookies, 0, new int[k]);
        return min;
    }

    // Backtracking method to find the minimum of maximum value
    private void backtrack(int[] cookies, int index, int[] dist) {
        // Base case: all cookies are distributed
        if (index == cookies.length) {
            min = Math.min(min, max(dist));
        } else {
            /* 
             * Try distributing the current cookie to each child and find 
             * the minimum value
             */
            for (int i = 0; i < dist.length; i++) {
                /* 
                 * If the distribution already exceeds the previously found min, 
                 * then discard this distribution
                 */
                if (dist[i] + cookies[index] >= min) continue;

                // Distribute cookie to child i
                dist[i] += cookies[index]; 
                backtrack(cookies, index + 1, dist);
                // Backtrack: remove the distributed cookie
                dist[i] -= cookies[index];
            }
        }
    }

    // Method to find the maximum value in a distribution
    private int max(int[] dist) {
        int maxValue = Integer.MIN_VALUE;
        // Find the maximum value in the distribution
        for (int i = 0; i < dist.length; i++) {
            maxValue = Math.max(maxValue, dist[i]);
        }
        return maxValue;
    }
}
```
</TabItem>
</Tabs>









### Complexity 

Let's say there are $N$ bags of cookies to distribute among $K$ children.

#### Time complexity 

$
O(K ^ N)
$

Each of the $N$ bag has $K$ options to choose from.


#### Space complexity

$
O(N + K)
$

Since there are $N$ bags to assign to each child, the stack size for the backtracking will be $N$. Additionally, an array of size $K$ is needed to hold the distribution of bags among the $K$ children.










<br />

## Similar questions

Here are some more questions that can be solved using the same technique.


### Probability of a Two Boxes Having The Same Number of Distinct Balls

The problem description can be found at [Leetcode 1467. Probability of a Two Boxes Having The Same Number of Distinct Balls](https://leetcode.com/problems/probability-of-a-two-boxes-having-the-same-number-of-distinct-balls/description/).


Let's visualize the problem for input array $\text{balls} = [2,1]$. Input array has $2$ balls of color $C1$, $1$ ball of color $C2$. The backtracking method starts with $\text{index} = 0$ and begins dividing the balls at that index into $2$ boxes.

<br />
<div style={{textAlign:"center"}}>

```mermaid
graph TD
    A([Start]) --> |0 C1 Ball to Box1 <br /> 2 C1 Ball to Box2| B[Box2: 2 Ball C1]
    A --> |1 C1 Ball to Box1<br>1 C1 Ball to Box2| C[Box1: <br /> 1 Ball C1 <br /><br /> Box2: <br /> 1 Ball C1]
    A --> |2 C1 Ball to Box1<br>0 C1 Ball to Box2| D[Box1: <br /> 2 Ball C1]

		B --> |0 C2 Ball to Box1<br>1 C2 Ball to Box2| E[Box2: <br /> 2 Ball C1 <br /> 1 Ball C2]
		B --> |1 C2 Ball to Box1<br>0 C2 Ball to Box2| F[Box1: <br /> 1 Ball C2 <br /><br /> Box2: <br /> 2 Ball C1]
		
    C --> |0 C2 Ball to Box1<br>1 C2 Ball to Box2| G[Box1: <br /> 1 Ball C1 <br /><br /> Box2: <br /> 1 Ball C1 <br /> 1 Ball C2]
    C --> |1 C2 Ball to Box1<br>0 C2 Ball to Box2| H[Box1: <br /> 1 Ball C1 <br /> 1 Ball C2 <br /><br /> Box2: <br /> 1 Ball C1]

		D --> |0 C2 Ball to Box1<br>1 C2 Ball to Box2| I[Box1: <br /> 2 Ball C1 <br /> <br /> Box2: <br /> 1 Ball C2]
		D --> |1 C2 Ball to Box1<br>0 C2 Ball to Box2| J[Box1: <br /> 2 Ball C1 <br /> 1 Ball C2]
``` 
</div>

<br />

Once we have all the possibilities ready, we mark the ones that satisfy the given condition and calculate the probability. 

In this question, we also calculate the combinations to determine how many different ways we can achieve the current configuration. For example, we calculate the number of ways to distribute $0$ balls of color $C1$ to Box$1$ and $2$ balls of color $C1$ to Box$2$.


<details>
  <summary>Solution</summary>

<Tabs>
  <TabItem value="Java" label="Java" default>

```java
class Solution {
    // Array to store factorials
    double[] factorial = new double[49]; 

    // Main method to calculate probability
    public double getProbability(int[] balls) {
        int sum = 0;
        // Calculate total number of balls
        for (int i = 0; i < balls.length; i++) {
            sum += balls[i];
        }

        // Calculate factorials for later use
        factorial[0] = 1;
        for (int i = 1; i < 49; i++) {
            factorial[i] = factorial[i - 1] * i;
        }

        // Calculate valid cases
        double valid = backtrack(balls, 0, 0, 0, 0, 0); 
        // Calculate total combinations
        double total = combinations(sum, sum / 2); 

        // Return probability
        return valid / total; 
    }

    // Backtracking method to calculate valid cases
    private double backtrack(int[] balls, int index, int box1Color, int box2Color,
      int box1Count, int box2Count) {

        if (index == balls.length) {
            // Check if counts and colors match for both boxes
            return box1Count == box2Count && box1Color == box2Color ? 1 : 0;
        } else {
            double res = 0;
            /*
             * Assign i balls from balls[index] to first box and 
             * balls[index] - i to second box
             */
            for (int i = 0; i <= balls[index]; i++) {
                double combinations = combinations(balls[index], i);
                res += backtrack(
                  balls, index + 1,
                  i > 0 ? box1Color + 1 : box1Color,
                  i < balls[index] ? box2Color + 1 : box2Color,
                  box1Count + i,
                  box2Count + (balls[index] - i)
                ) * combinations;
            }
            return res;
        }
    }

    // Method to calculate combinations using factorials
    private double combinations(int n, int r) {
        return factorial[n] / factorial[n - r] / factorial[r];
    }
}
```
</TabItem>
</Tabs>
</details>




###  Find Minimum Time to Finish All Jobs

The problem description can be found at [Leetcode 1723. Find Minimum Time to Finish All Jobs](https://leetcode.com/problems/find-minimum-time-to-finish-all-jobs/description/).


<details>
  <summary>Solution</summary>

<Tabs>
  <TabItem value="Java" label="Java" default>

```java
class Solution {
    private int min = Integer.MAX_VALUE;

    // Main method to calculate minimum time required
    public int minimumTimeRequired(int[] jobs, int k) {
        backtrack(jobs, 0, new int[k]);
        return min;
    }

    // Backtracking method to find the minimum of maximum value
    private void backtrack(int[] jobs, int index, int[] workers) {
        // Base case: all jobs are assigned
        if (index == jobs.length) {
            min = Math.min(min, max(workers));
        } else {
            // Try assigning the current job to each worker and find the minimum value
            for (int i = 0; i < workers.length; i++) {
                // If the current assignment is the same as the previous one, skip
                if (i > 0 && workers[i] == workers[i - 1]) continue;

                // If the current assignment exceeds the previously found min, then discard
                if (workers[i] + jobs[index] > min) continue;

                workers[i] += jobs[index]; // Assign job to worker i
                backtrack(jobs, index + 1, workers);
                workers[i] -= jobs[index]; // Backtrack: remove the assigned job
            }
        }
    }

    // Method to find the maximum value in an array
    private int max(int[] array) {
        int maxValue = Integer.MIN_VALUE;
        // Find the maximum value in the array
        for (int i = 0; i < array.length; i++) {
            maxValue = Math.max(maxValue, array[i]);
        }
        return maxValue;
    }
}
```
</TabItem>
</Tabs>
</details>








