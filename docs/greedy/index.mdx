---
slug: /greedy
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

#  Greedy

This page offers detailed explanations and Java solutions for problems, using the Greedy technique.


## Maximum Bags With Full Capacity of Rocks

The problem description can be found at [Leetcode 2279. Maximum Bags With Full Capacity of Rocks](https://leetcode.com/problems/maximum-bags-with-full-capacity-of-rocks/).


### Explanation 

The idea is straightforward identify the bag requiring the fewest additional rocks, then greedily start filling that \
bag first until you run out of addional rocks.


Let's take the sample input below,

<br />
$$
\text{capacity} = \begin{bmatrix}
2, 3, 4, 5
\end{bmatrix}, \
\text{rocks} = \begin{bmatrix}
1, 2, 4, 4
\end{bmatrix}, 
\  \text{additionalRocks} = 2
$$
<br />

First, we'll create an array called $\text{requiredRocks}$, where each element is the bag's capacity minus the rocks already in the bag at the $i^{th}$ position.

After obtaining $\text{requiredRocks}$, sort that array and apply a greedy technique to start filling the bags.

### Implementation
<Tabs>
  <TabItem value="Java" label="Java" default>

```java
class Solution {
    public int maximumBags(int[] capacity, int[] rocks, int additionalRocks) {
        int n = rocks.length;
        int[] requiredRocks = new int[n];
				
        //calculate requiredRocks array 
        for(int i = 0; i < n; i++) {
            required[i] = capacity[i] - rocks[i];
        }

        //sort requiredRocks array
        Arrays.sort(required);

        //start filling bag with least requiredRocks first 
        int index = 0;
        while(additionalRocks > 0 && index < required.length) {
            if(additionalRocks >= required[index]) {
                additionalRocks -= required[index++];
            }
            else break; // break if additionalRocks can't fill current bag
        }
        return index;
    }
}
```
</TabItem>
</Tabs>

### Complexity 

Let's say there are $N$ elements in a rock's array.

#### Time complexity 
$
O(N \ \text{log} \ N)
$

#### Space complexity
$
O(N)
$



<br />

## Similar questions

Here are some more questions that can be solved using the same technique.

### Find Minimum Time to Finish All Jobs II

The problem description can be found at [Leetcode 2323. Find Minimum Time to Finish All Jobs II](https://leetcode.com/problems/find-minimum-time-to-finish-all-jobs-ii/description/).


<details>
  <summary>Solution</summary>

<Tabs>
  <TabItem value="Java" label="Java" default>

```java
import java.util.Arrays;

class Solution {
    // Main method to calculate minimum time required
    public int minimumTime(int[] jobs, int[] workers) {
        // Sort jobs and workers arrays
        Arrays.sort(jobs);
        Arrays.sort(workers);
        
        int min = 0;

        // Iterate through jobs
        for (int i = 0; i < jobs.length; i++) {
            // Calculate days needed for current job and worker
            int days = jobs[i] / workers[i];
            if (jobs[i] % workers[i] > 0) days++;

            // Update min with the maximum of current days and previous min
            min = Math.max(min, days);
        }

        return min;
    }
}
```
</TabItem>
</Tabs>
</details>