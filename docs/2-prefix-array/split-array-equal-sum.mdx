import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';



#  Split Array with Equal Sum

This page explains Java solution to leetcode problem [548. Split Array with Equal Sum](https://leetcode.com/problems/split-array-with-equal-sum/description/) using Prefix Array algorithm.






## Explanation 



Let's take the sample input as below,

<br />
$$
\text{nums} = \begin{bmatrix}
1, 2, 1, 2, 1, 2, 1
\end{bmatrix}
$$
<br />


To solve this problem, we traverse through all array indices to establish the value for $j$. Inside the inner loop, we assign $i$ satisfying $0 < i < j$ and $k$ such that $j < k < $ nums.length.


Next, adjust the starting and maximum values for $i$, $j$, and $k$ to fit the conditions outlined in the question.

## Implementation
<Tabs>
  <TabItem value="Java" label="Java" default>

```java
import java.util.HashSet;

class Solution {
    public boolean splitArray(int[] nums) {
        int[] prefix = new int[nums.length];
        prefix[0] = nums[0];

        // Calculate prefix sums
        for (int i = 1; i < nums.length; i++) {
            prefix[i] = prefix[i - 1] + nums[i];
        }

        // Picking value of 'j'
        for (int middle = 3; middle < nums.length; middle++) {
            HashSet<Integer> set = new HashSet<>();

            // Picking value of 'i'
            for (int left = 1; left + 1 < middle; left++) {
                int first = sum(0, left - 1, prefix);
                int second = sum(left + 1, middle - 1, prefix);
                if (first == second) {
                    set.add(first);
                }
            }

            // Picking value of 'k'
            for (int right = middle + 2; right + 1 < nums.length; right++) {
                int third = sum(middle + 1, right - 1, prefix);
                int fourth = sum(right + 1, nums.length - 1, prefix);
                if (third == fourth && set.contains(third)) {
                    return true;
                }
            }
        }
        return false;
    }

    // Method to calculate sum within a range using prefix sums
    private int sum(int from, int to, int[] prefix) {
        return prefix[to] - (from - 1 > 0 ? prefix[from - 1] : 0);
    }
}
```
</TabItem>
</Tabs>








## Complexity 

Let's say there are $N$ elements in an array.

### Time complexity 
$
O(N^2)
$

### Space complexity
$
O(N)
$

